-----------蓝牙音乐获取时间---------
handleAvrcpCtNotiPlaybackPosInd ind 手机上报 ，handleAvrcpCtGetPlayStatusCfm cfm是函数获取的
csr_bt_avrcp_down.c
start_get_play_status()

-----------c语言---------------------
atoi() 函数会扫描参数str字符串，跳过前面的空白字符(例如空格，tab缩进等，可以通过isspace()函数来检测)，
直到遇上数字或正负号才开始做转换，而再遇到非数字或字符串结束时('\0')才结束转换，并将结果返回
例子：
#include <stdio.h>
#include <stdlib.h>
int main()
{
    int i;
    char buffer[256];
    printf("请输入数字: \n");
    fgets(buffer,256,stdin);
    i = atoi(buffer);
    printf("i=%d\n",i);
    return 0;
}

-----------ubuntu-------------------
sudo apt install vim //更新vi编译器
sudo apt-get install net-tools //ubuntu中下载ipconfig(查看ip地址)
sudo mount -t vboxsf ***(共享文件夹名字) /mnt/share  //挂载共享文件夹
串口通信查看ttyUSB0
插入串口，打开设备下的USB的USB设置
添加USB选中插入的USB口
回到设备下的USB，选中刚刚添加的USB设备名称，有✔就成功添加
ls -a /dev/*USB*  //查看设备

----------------x20------------------
HCI_Link_Key_Notification //Link_key 文件查找
sc_db.db 文件用对比文件打开
spp  frame size 是数据大小 :RFCOMM 中Length：为数据长度
master 为 对方发送
slave 为 自己的发送

---------原生蓝牙linkey查看----------------
cat /data/misc/bluedroid/bt_config.conf


-------abd找密匙-------------------
win+r
cmd
adb devices
adb shell
cd /data/goc
ls
复制bt_snoop_20211114154926.cfa
exit
adb pull /data/goc/bt_snoop_20211114154926.cfa
start .
复制文件bt_snoop_20211114154926.cfa到没有中文路径下打开
查找HCI_Link_Key_Notification最后一个
确定密匙 Link_Key: 0x7a 64 1f 95 dc 6b f8 a8 86 43 0d fe 9d 11 92 f5


-------eclipse代码编译后板子上运行-------------------
adb connect  + ip地址 //连接板子(同一个局域网内)
win + r
cmd
dir  //查看报告
cd  Music\tcpadb\
adb root  //给root权限
adb remount  //重新挂载
adb push  .\s  /system/bin  //将服务器拷贝到板子的运行路径下去
adb push  .\c /system/bin  //将客户端拷贝到板子的运行路径下去
adb shell  //进去板子的控制系统,linux命令可用
cd  system/bin/  //进入运行路径
./s 3000        //运行代码
打开另一个命令窗口
adb shell  //进去板子的控制系统,linux命令可用
cd  system/bin/  //进入运行路径
ifconfig  //查看ip地址
./c 127.0.0.1 3000 
可以实现功能

adb pull system/bin  ./   //将板子的东西拷贝到当前文件夹
adb pull /usr/bin/gocsdk F:\ADB //将板子的东西拷贝到文件夹下
start .  //打开当前文件夹位置

adb connect 192.168.137.145   //网络adb使用方法
adb root
adb connect 192.168.137.145
adb remount
adb shell

在将代码push进去后可以直接运行
打开另一个终端输入下面命令
adb logcat -v time |grep goc
adb logcat -s goc   //查看日志运行状态
ps  -A  |grep gocsdk 查看进程是否运行
reboot 重启
adb logcat -s goc > F:/log/log.txt  //将日志保存在F盘中的文件中
echo AT#AA6091F3F9EBE6>/dev/goc_serial  手动开启功能
adb devices //查看当前设备
adb logcat -v time >log.txt //保存日志到log.txt
ctrl + z   //杀掉 logcat -s goc
logcat -v time   //以时间问单位打开日志
logcat |grep -Ei "goc"  //以goc筛选日志 
logcat |grep -Ei "adapter|blue|debug|androidruntime" //原生机器log
logcat |grep -Ei "adapter|AEE_AED|BLUE|androidruntime"

svc bluetooth disable
svc bluetooth enable

-----------设置自己的代码开机自启动将文件gocsdk.rc-------------
代码内容为：
service gocsdk /system/bin/gocsdk
    class main
    user root
    group root
    seclabel u:r:shell:s0
放在 /vendor/etc/init里

代码内容2：
service gocsdk_s /system/bin/gocsdk_s
    class main
    user root
    group root
    seclabel u:r:shell:s0
    setenv LD_LIBRARY_PATH /vendor/lib:/vendor/lib/hw
    disabled
on property:persist.sys.bt.goc=1
    start gocsdk
这个开机自启动,需要配置系统属性
查看属性值：
getprop  persist.sys.bt.goc
设置属性值：
setprop  persist.sys.bt.goc 1

----------------------Android12的remount失败--------------------
进入开发者模式，开启OEM模式
adb reboot  bootloader  
flashboot  flashing  unlock  //解锁操作
机器上操作，选择YES
flashboot  reboot
adb root
adb remount

-------------------段错误地址打印)查询段错误位置-------------------
logcat -v time -s DEBUG

打开项目使用的ndk -e + 出问题的obj文件的具体文件，由DEBUG段错误报错决定  + 错误编号(DEBUG) 
c:\android-ndk-r16b\toolchains\x86_64-4.9\prebuilt\windows-x86_64\bin\x86_64-linux-android-addr2line.exe
-e  c:\eclipse_daima\zhixing\obj\local\armeabi-v7a\gocsdk   002b4bf6

android-ndk-r25b\toolchains\llvm\prebuilt\windows-x86_64\bin

------------------MTK debug信息打开方式---------------------------
    setprop ro.vendor.aee.enforcing no
    setprop persist.vendor.aeev.core.dump enable      
    setprop persist.vendor.aeev.core.direct enable
    setprop persist.vendor.mtk.aee.mode 3
    setprop persist.vendor.mtk.aeev.mode 3
    setprop persist.vendor.mtk.aee.filter 0


logcat -s goc AEE_AED DEBUG system.err

-----------------设置gocsdk.so不报错--------------------------------
改arch/gocsdk/Android.mk
LOCAL_MODULE := gocsdk.so
C:\android-ndk-r25b\build\core\definitions.mk文件下的：

ifneq (,$$(filter %$$(TARGET_LIB_EXTENSION) %$$(TARGET_SONAME_EXTENSION),$$(LOCAL_MODULE_FILENAME)))
    $$(call __ndk_info,$$(LOCAL_MAKEFILE):$$(LOCAL_MODULE): LOCAL_MODULE_FILENAME must not contain a file extension)
    $$(call __ndk_error,Aborting)
endif
改为：
#ifneq (,$$(filter %$$(TARGET_LIB_EXTENSION) %$$(TARGET_SONAME_EXTENSION),$$(LOCAL_MODULE_FILENAME)))
#    $$(call __ndk_info,$$(LOCAL_MAKEFILE):$$(LOCAL_MODULE): LOCAL_MODULE_FILENAME must not contain a file extension)
#    $$(call __ndk_error,Aborting)
#endif

-----------------查看库文件的解析//看到安卓源文件-------------------
android-ndk-r25b-windows.zip\android-ndk-r25b\toolchains\llvm\prebuilt\windows-x86_64\bin>llvm-readelf.exe -aC + 有外部接口的库文件 > 输出的文件
例子：
android-ndk-r25b-windows.zip\android-ndk-r25b\toolchains\llvm\prebuilt\windows-x86_64\bin>llvm-readelf.exe -aC E:\32\libaudioclient.so > audioclient2.txt

---------------查看蓝牙声卡---------------------
cat /proc/asound/pcm

00-00: Loopback PCM : Loopback PCM : playback 8 : capture 8
00-01: Loopback PCM : Loopback PCM : playback 8 : capture 8
01-00: Playback_1 (*) :  : playback 1
01-01: Playback_12 (*) :  : playback 1
01-02: Playback_2 (*) :  : playback 1
01-03: Playback_5 (*) :  : playback 1
01-04: Capture_1 (*) :  : capture 1
01-05: Capture_2 (*) :  : capture 1
01-06: Capture_3 (*) :  : capture 1
01-07: Capture_4 (*) :  : capture 1
01-08: Capture_7 (*) :  : capture 1
01-09: Capture_Mono_1 (*) :  : capture 1
01-10: Hostless_LPBK (*) :  : playback 1 : capture 1
01-11: Hostless_FM (*) :  : playback 1 : capture 1
01-12: Hostless_Speech (*) :  : playback 1 : capture 1
01-13: Hostless_Sph_Echo_Ref (*) :  : playback 1 : capture 1
01-14: Hostless_Spk_Init (*) :  : playback 1 : capture 1
01-15: Hostless_ADDA_DL_I2S_OUT (*) :  : playback 1
01-30: BTCVSD snd-soc-dummy-dai-30 :  : playback 1 : capture 1

30为蓝牙声卡
--------------------编译android源码步骤---------------------------
liugenlin@server:mt67_68xx_12.0$ cat ReadMe.txt
//首先进入所需工程目录
//mt67_68xx_12.0
1.source build/envsetup.sh
2.lunch 83
3.make -j12 | tee build.log 2&>1&

----------------关闭SElinux权限------------------------
getenforce //查看权限
setenforce 0


-----------------Android系统库文件保存位置-----------------------
/system/etc/public.libraries.txt
非Android系统库，会出现概率链接不到。


-------eclipse代码编译后覆盖板子上的原代码后运行-------------------
将自己的代码替换掉 /vendor/bin 目录下的 gocsdk    (ls -l goc*)可以查找
重启后就可以使用自己的代码



-------eclipse代码编译报错总结-------------------
1. ndk环境23不支持，后安装18可以编译不报错
2. ndk 编译链报错
问题是：
Android NDK: NDK Application 'local' targets unknown ABI(s): armeabi - hf
Android NDK: Please fix the APP_ABI definition in C:/eclipse_daima/jni/Application.mk
C:/linux-ndk-r12b/build//../build/core/setup-app.mk:120: *** Android NDK : Aborting
"C:/linux-ndk-r12b/ndk-build.cmd CUSTOMER=T3_Linux_BF440_HongYing_LIANXI_zj -B -j8 -B ...
解决办法:
是因为代码里面的cnfig.mk 编译中的APP_ABI:= armeabi-hf 没有对应ndk编译链
去更改为 APP_ABI:= armeabi 就能成功编译
3.gocsdk明明在路径下却报错说没有文件和目录
可能的原因有: 没有权限，可以 chmod  777 gocsdk 
可能有编译链有问题，比如使用软浮点的车机却使用了硬浮点的代码，这个时候就需要重新更改编译链


------------230日志打不开-----------------------
goc_config.c 中 is_goc_debug TRUE 打开后没有作用可检查

common.mk文件中
	DEBUG_PORT     := 1
//             DEBUG_PORT  1 是输出跟打印同一个串口输出,
//                                     2 是打印跟输出串口不一样

//更改后可能存在问题，功能不能实现可以更改
	Makefile 中更改为 HAS_SPLITE_UART := 0
                 //HAS_SPLITE_UART是否将串口和打印分开 1分开,0是不分开


-------------BLE--------------------
0  ble做主机要求
 1AT#LC0,[uuid:36][role:1]   此指令为注册ble蓝牙服务
	uuid：目前固定为00000000-0000-0000-0000-000000002002
	role: 为ble 的角色   0：做从   1：做主
	eg:AT#LC0,00000000-0000-0000-0000-0000000020021
    状态回复：
      LR0,[gattid],[status],[uuid]
	status:注册状态    0 ：注册成功   1 注册失败
	eg:LR0,327701,0,00000000-0000-0000-0000-000000002002

2AT#LS1 此指令是扫描ble
	eg:AT#LS1

    状态回复：
      LP,[evt_type],[addr_type],[str_addr],[primary_phy],[secondary_phy],[advertising_sid],[tx_power],[rssi],[periodic_adv_int],[data_len],[data]
//ble4.2广播数据类型 https://blog.csdn.net/freemote/article/details/119345553
LP70013,00,F44EFD0011CD,01,00,FF,7F,C3,0000,1F,020106050312180F180319800111094274566F696365417373697374616E74
1F  020106050312180F180319800111094274566F696365417373697374616E74   //1F:31 62
020106 050312180F18 03198001 11 09 42 74 56 6F 69 63 65 41 73 73 69 73 74 61 6E 74	
					     B  t  V  o  i  c  e  A  s  s  i  s  t  a  n  t  //16+1 = 17


primary_phy：主要的phy
secondary_phy：次要的phy
tx_power：发射功率
rssi： 接收信号强度指示器
advertising_sid：广告的sid
ble做主只需要注册ble蓝牙服务

-----------------------------------------------------------------

1  新增ble 做从机需求
相关指令：
 1AT#LC0,[uuid:36][role:1]   此指令为注册ble蓝牙服务
	uuid：目前固定为00000000-0000-0000-0000-000000002002
	role: 为ble 的角色   0：做从   1：做主
	eg:AT#LC0,00000000-0000-0000-0000-0000000020020
    状态回复：
      LR0,[gattid],[status],[uuid]
	status:注册状态    0 ：注册成功   1 注册失败
	eg:LR0,327701,0,00000000-0000-0000-0000-000000002002
 
 2 AT#LC12,[gattid],[servicetype:1],[serveruuid] 此指令为添加ble 主服务
	gattid:注册不了服务时，返回的id
	servicetype:需要注册的主服务的类型，1: 16位的uuid,  2: 32位的uuid, 3: 128位uuid(2,3 协议栈暂时添加)
	serveruuid：要使用的ble 主要服务的uuid  
	eg:AT#LC12,327701,1,FFE0

3 AT#LC13,[gattid],[servicetype:1],[properties],[valuelenth],[value],[charauuid] 此指令为添加ble 特征服务（Characteristic则是GATT profile中最基本的数据单位，由一个Properties、一个Value、一个或者多个Descriptor组成）
	gattid:注册不了服务时，返回的id
	servicetype:需要注册的主服务的类型，1: 16位的uuid,  2: 32位的uuid, 3: 128位uuid(2,3 协议栈暂时添加)
	properties:特征服务的属性值，常用的有 read:0x02  write:0x08 notify:0x10
	valuelenth：特征值长度
	value：特征值 （可以没有特征值）
	charauuid：特征uuid
	eg:AT#LC13,327701,1,26,0,,0001

 4 AT#LC11,[gattid],[eventmask]  此指令为允许gatt 订阅事件
	eventmask: 0 没有订阅事件，1 订阅物理链路状态事件， 2 订阅白名单改变事件， 3 连接参数更新等； 默认为0
	eg：AT#LC11,327701,0

 5 AT#LC15,[gattid] 此指令为生成上面所添加的所有服务
	eg:AT#LC15,327701  

   状态回复：
    LR3,[gattid],[connectind],[index],[attribute_type],[length],[starthandle],[endhandle]
	eg:LR3,1048576,2,3,1018,16,E2FF,1017

 6 AT#LC10,[gattid]  此指令为注销ble
	eg:eg:AT#LC10,327701  

 7 AT#LC16,[gattid],[[endhandle]],[write_type],[auth_req],[data_len],[data]  此指令为发送数据给ble设备
	[endhandle]:被通知的特征值句柄，为0的情况下，协议栈会自动查找handle,当注册多个属性时，需要指定handle
	write_type: 默认为0
	auth_req:默认为0
	data_len: 发送的数据长度
	data: 发送的数据
	eg:AT#LC16,327701,1017,0,0,3,123

8 收到ble  notify 数据的状态
	LR8,[gattid],[connect_id],[addr:12],[handle],[len],[data],[is_notify]
	eg:LR8,327701,1048576,68BFAF520B79,1015,7,1234568,0

9 LR1,[gattid],[connectid],[status],[addr:12]   //ble 连接成功状态回调
	eg:LR1,196628,1048576,0,5C17092A5B6F

10 LR9,[gattid],[connectid],[status],[addr:12]   //ble 断开状态回调
	eg:LR9,196628,1048576,0,5C17092A5B6F
从机ble 按上面 1 2 3 4 5 步骤操作后，手机就可以连接指定ble 服务 进行数据交互

-------------烧入工具--------------------
dld_main 账号密码为 1，1


-------------下载apk软件命令------------
adb  install -r   +  .apk


-----------内置协议栈--------------------
内置协议栈都是原生的，运行自己的代码时，需要将机器原生的蓝牙干掉，
不然自己的代码不能运行起来

-------------加密步骤--------------------
加密需要设置3个参数
goc_config.c里
set_databasepath("/data/goc");  //需要客户确认
profile_set_enc_pwdtype(0xb1);  //是需要代总提供更改的
const char* get_customer_id()
{
	return "GOC-TEST";
}  // 是需要提供给代总，调试的时候使用GOC-TEST。

一般获取唯一识别码的方法
getprop |grep serial

-------------SOCKET通信----------------
进程间通信
#include <sys/socket.h>
#include <sys/un.h>

//PF_UNIX用来在同一机器上的提供有效的进程间通讯
unix_socket = socket(PF_UNIX,type,0)   
error = socketpair(PF_UNIX, type, 0, int *sv);

---------------Android系统中获取设备信息------------
getprop命令：

查询Android设备的所有配置信息
adb shell getprop
在所列出的配置当中，以ro开头的是只读属性

查看Android设备单个配置信息
adb shell getprop  <prop-name>
例：查看单板的信息
adb shell getprop ro.product.board
查看进程默认虚拟机最大堆内存
adb shell getprop dalvik.vm.heapgrowthlimit

setprop对Android系统进行配置设置(ro类型不能被设置)
setprop <prop-name> <value>
例：修改进程默认分配的可以使用堆内存大小:
adb shell setprop dalvik.vm.heapgrowthlimit 128m

-----------------属性设置----------------
hci权限：
setprop persist.bluetooth.btsnoopenable true

getprop persist.bluetooth.btsnoopenable
全log：
setprop get_log_level true
getprop get_log_level

setprop e_log_level_info true
getprop e_log_level_info 

配置录音文件:
setprop persist.sys.bt.audio  true
----------------查看安卓版本-------------
getprop | grep sdk


-----------------后台启动软件------------
gocskd&

-----------------保存开机日志----------------
dmesg命令默认的时间显示是从开机到log记录的时间
adb shell dmesg > demsg.txt
start .  ///注意这里有点

----------------查看机器可执行文件----------
which gocsdk

---------------系统驱动----------------
查看系统驱动命令：
	lsmod
卸载系统驱动：
	rmmod  + 驱动名称

------------md5码---------------------
md5sum  libGbtsDriver.so

----------------内核日志-------------------
把它重定向到文件
sh -c /mnt/nfs/gocsdk.so 2 >&1 | tee /opt/pub/bt_stack.txt&


---------------配置环境变量---------------
export LD_LIBRARY_PATH=/vendor/lib:/vendor/lib/hw
export ld_library_path

---------------Android音频底层调试工具(tinymix,tinypaly,tinycap)----------
tinymix可以查看系统的音频控件
例子:
tinymix -D I 176 0
tinyplay 可以直接进行播放wav格式文件
例子:
tinyplay  xxx.wav

tinycap 可以录音
例子:
tinycap xxx.wav

----------------多台adb设备进入方法--------------------
adb -s + addr + shell

-------------广播----------------------

-------------上传代码-------------------
桌面界面右键SVN Checkout
选中目标文件夹，右键选中Create folder新建文件夹
将新建文件夹下载下来，将要上传的文件复制进入下载的新建文件夹
全选右键TortoiseSVN中的add
add成功后，右键SVN Commit 输入更新的日志，点击ok开始上传，成功后点击ok就完成上传

-------------eclipse快捷键----------
ctrl + O (查看函数）
ctrl + shift + f （函数对齐）

------------旧协议栈的gocsdk.so无法下载--------
将gocsdk.so改为gocsdk.exec

-------------建立同步链接--------------------
命令：Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。
当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。

例子： cd /system/lib
	ln -s /data/goc/libGbtsDriver.so  libGbtsDriver.so


------------iinker-------------------
linker主要作用：加载可执行程序依赖的库；查找修改被引用的符号（称为符号解析或者重定向）。

-----------蓝牙启动流程----------------
代码启动会去打印模块型号（get_module_name（））
然后会去打开伪终端ptmx
#include <stdlib.h>
int grantpt(int filedes);
int unlockpt(int filedes);
两个函数的返回值: 若成功则返回0，若出错则返回-1

grantpt函数提供的功能：在伪终端从设备可被使用之前，必须设置它的权限，使得应用程序可以访问它。它把从设备节点的用户ID设置为调用者的实际用户ID, 设置其组ID为一非指定值，通常是可以访问该终端设备的组。将权限设置为：对单个所有者是读写，对组所有者是写（0620）。
unlockpt函数用于准予对伪终端从设备的访问，从而允许应用程序打开该设备。阻止其他进程打开从设备，使得建立该设备的应用程序有机会在使用主、从设备之前正确地初始化这些设备。

ptsname()函数返回与文件描述符fd引用的主设备对应的从伪终端设备的名称。
ptsname_r()函数是ptsname()的可重入等价函数。它返回从伪终端设备的名称，作为buf指向的缓冲区中的一个以空字符结尾的字符串。buflen参数指定了可用的字节数在缓冲区。

symlink(target,link)创建一个从指定名称连接的现存目标文件开始的符号链接

-----------------hid------------
hidh = hid host  
hidd = hid devices

--------------手机取消配对继续弹框问题------
gap_app.c
void handleGapBondInd
else{
	ap_send_pair_state(&deviceAddr,cod,instData->scVar.name,0,1);
	//修改点
	dm_acl_disconnect_by_addr(deviceAddr);
}
	memset(instData->passkey_singal,0,sizeof(instData->passkey_singal));
}

csr_bt_gap_app_sc.c
static void csrBtScRebondIndFunc
//修改点
// handleGapREbondInd(cod,deviceAddr,deviceName,addressType);
dm_acl_disconnect_by_addr(deviceAddr);

-------------将16k音频文件转换为8k音频文件------------
jni/apm/apm.cc
extern "C" unsigned int apm_onlyAnalyzeReverse(){
	
	if(sample_rate != APM_SAPLE_RATE){
		resampler_new() //
		resampler_resample()
	}
}

-------------小系统riscv Linux的ndk修改------------
1.
目录/riscv64-unknown-linux-gnu-10.2.0 是需要自己创建，从原有的基础上复制 //格式为：riscv64-unknown-linux-gnu-（+版本号）
/android-ndk-r12b/build/core/toolchains/riscv64-unknown-linux-gnu-10.2.0/config.mk
TOOLCHAIN_ARCH := riscv_64  //对应代码 config.mk文件，名字可自己定义
TOOLCHAIN_ABIS := riscv_64
2.
将编译链Ubuntu里解压，
/android-ndk-r12b/toolchains/riscv64-unknown-linux-gnu-10.2.0/prebuilt/linux-x86_64/里替换解压的文件
3.
代码编译，报什么错，看需要修改什么


-------------查看软件需要链接的库文件----------
arm-linux-androideabi-readelf -d gocsdk.so
arm-linux-androideabi-readelf -d libGbtsTask.so

------------Android手机连接adb不弹出允许调试窗口---------
adb root 
adb: unable to connect for root: device unauthorized.
This adb server's $ADB_VENDOR_KEYS is not set
Try 'adb kill-server' if that seems wrong.
Otherwise check for a confirmation dialog on your device.
解决方法：
adb kill-server
adb start-server
再重新插拔usb线


-----------Android手机获取hci日志和所有错误报告------------
adb bugreport .

小米手机  *#*#5959#*#*  路径：/sdcard/MIUI/debug_log/

-------------原生蓝牙--------------------
使用am start命令启动android apk应用程序
 am start -n com.android.settings/.Settings

--------------Android系统设置机器内置时间-----------
adb root
adb remount
adb shell
date //查看机器时间
date 2023-06-14 //设置机器日期
date 06141157.00  //设置时间为 6月14日11点57分00秒 


--------------查看Android系统分区-----------------
mount


--------------linux的录音播放程序代码基于alsa------------------
#include <stdio.h>
#include <stdlib.h>
#include <alsa/asoundlib.h>

#define BUFFER_SIZE 1024

int main() {
    int err;
    unsigned int sample_rate = 44100;
    unsigned int channels = 2;
    snd_pcm_t *capture_handle, *playback_handle;
    snd_pcm_hw_params_t *hw_params;

    // 打开默认录音设备
    err = snd_pcm_open(&capture_handle, "default", SND_PCM_STREAM_CAPTURE, 0);
    if (err < 0) {
        printf("无法打开录音设备: %s\n", snd_strerror(err));
        return 1;
    }

    // 打开默认播放设备
    err = snd_pcm_open(&playback_handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
    if (err < 0) {
        printf("无法打开播放设备: %s\n", snd_strerror(err));
        return 1;
    }

    // 分配硬件参数对象
    err = snd_pcm_hw_params_malloc(&hw_params);
    if (err < 0) {
        printf("无法分配硬件参数对象: %s\n", snd_strerror(err));
        return 1;
    }

    // 初始化硬件参数对象
    err = snd_pcm_hw_params_any(capture_handle, hw_params);
    if (err < 0) {
        printf("无法初始化硬件参数: %s\n", snd_strerror(err));
        return 1;
    }

    // 设置硬件参数：采样率、声道数和格式
    err = snd_pcm_hw_params_set_rate_near(capture_handle, hw_params, &sample_rate, 0);
    if (err < 0) {
        printf("无法设置采样率: %s\n", snd_strerror(err));
        return 1;
    }
    err = snd_pcm_hw_params_set_channels(capture_handle, hw_params, channels);
    if (err < 0) {
        printf("无法设置声道数: %s\n", snd_strerror(err));
        return 1;
    }

    // 将硬件参数应用到录音设备
    err = snd_pcm_hw_params(capture_handle, hw_params);
    if (err < 0) {
        printf("无法设置硬件参数到录音设备: %s\n", snd_strerror(err));
        return 1;
    }

    // 将硬件参数应用到播放设备
    err = snd_pcm_hw_params(playback_handle, hw_params);
    if (err < 0) {
        printf("无法设置硬件参数到播放设备: %s\n", snd_strerror(err));
        return 1;
    }

    // 分配缓冲区
    char *buffer = (char *)malloc(BUFFER_SIZE * snd_pcm_format_width(SND_PCM_FORMAT_S16_LE) / 8 * channels);

    // 开始录音和播放
    while (1) {
        // 从录音设备读取音频数据
        err = snd_pcm_readi(capture_handle, buffer, BUFFER_SIZE);
        if (err < 0) {
            printf("读取录音数据失败: %s\n", snd_strerror(err));
            break;
        }

        // 播放音频数据
        err = snd_pcm_writei(playback_handle, buffer, err);
        if (err < 0) {
            printf("播放音频数据失败: %s\n", snd_strerror(err));
            break;
        }
    }

    // 释放资源
    free(buffer);
    snd_pcm_hw_params_free(hw_params);
    snd_pcm_close(capture_handle);
    snd_pcm_close(playback_handle);

    return 0;
}

/*这段代码首先使用snd_pcm_open函数打开默认的录音设备和播放设备，
然后使用snd_pcm_hw_params_malloc函数分配硬件参数对象。接下来，代码使用snd_pcm_hw_params_any函数初始化硬件参数对象，
并使用snd_pcm_hw_params_set_rate_near和snd_pcm_hw_params_set_channels函数设置采样率和声道数。
然后，通过snd_pcm_hw_params函数将硬件参数应用到录音设备和播放设备。
代码中的主循环使用snd_pcm_readi函数从录音设备读取音频数据，并使用snd_pcm_writei函数将音频数据写入播放设备进行播放。循环将一直运行，直到发生错误。
最后，代码释放缓冲区和硬件参数对象，并使用snd_pcm_close函数关闭录音设备和播放设备。
请注意，此示例代码非常简化，并且没有包含错误处理的完整逻辑。
在实际应用中，您应该添加适当的错误处理代码以及其他功能，例如录音时间限制、静音检测等。*/



------------.mk 文件中，= 、:= 、?= 、+= 的区别----------------
= 是最基本的赋值
:= 是覆盖之前的值
?= 是如果没有被赋值过就赋予等号后面的值
+= 是添加等号后面的值

而 = 与 := 的区别在于，= 会在makefile 展开后再决定变量的值，即最后被指定的值

eg：

            x = foo
            y = $(x) bar
            x = xyz

      在上例中，y的值将会是 xyz bar ，而不是 foo bar 。

而:= 表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。
在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。

-----------------------lsof---------------------------------
lsof是List open File获取被进程打开文件的信息。
lsof命令可以查看所有已经打开了的文件，比如: 普通文件，目录，特殊的块文件，管道，socket套接字，设备，Unix域套接字等等，同时，它还可以结合 grep 以及 ps 命令进行更多的高级搜索

----------------------并发程序--------------------------
#include <sys/wait.h>
pid_t wait(int * statloc);
pid_t waitpid(pid_t pid,int *statloc,int options);

pid_t wait(int * statloc);
主要功能：
阻塞当前进程
等待其子进程退出并回收其系统资源
解析：
如果当前进程没有子进程，则该函数立即返回。
如果当前进程有不止1个子进程，则该函数会回收第一个变成僵尸态的子进程的系统资源。
子进程的退出状态（包括退出值、终止信号等）将被放入wstatus所指示的内存中，若wstatus指针为NULL，则代表当前进程放弃其子进程的退出状态。

#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <sys/wait.h> 

int main()
{
    if(fork() == 0)
    {
        printf("[%d]: 我将在3秒后正常退出，退出值是88\n", getpid());

        for(int i=3; i>=0; i--)
        {
            fprintf(stderr, " ======= %d =======%c", i, i==0?'\n':'\r');
            sleep(1);
        }

        exit(88);
    }

    else
    {
        printf("[%d]: 我正在试图回收子进程的资源...\n", getpid());

        int status;
        wait(&status);

        if(WIFEXITED(status))
        {
            printf("[%d]: 子进程正常退出了，其退出值是：%d\n", getpid(), WEXITSTATUS(status));
        }
    }
}
执行结果：
gec@ubuntu:$ ./a.out
[3611]: 我正在试图回收子进程的资源...
[3612]: 我将在3秒后正常退出，退出值是88
 ======= 0 =======
[3611]: 子进程正常退出了，其退出值是：88
gec@ubuntu:$ 

pid_t waitpid(pid_t pid,int *statloc,int options);

pid:
	 < -1: 取该 pid 的绝对值，如果任何子进程的进程组ID等于该值，则该进程组的任一子进程中的进程状态发生变化，都会触发`waitpid`的回调;
        == -1: 监听范围扩大到任意子进程，也就是 wait(status)；
        ==  0: 监听进程组ID和父进程一样的子进程；
         >  0: 监听该pid的子进程；

options:
	WNOHANG： 调用时，指定的 pid 仍未结束运行，则 wait 立即返回 0；
        WUNTRACED： 当子进程被暂停时，则立即返回子进程的 pid;
        WCONTINUED: 当被暂停的子进程，又被信号恢复时，则立即返回子进程的pid；

------------------信号集操作函数组----------------
// 信号集操作函数组
#include <signal.h>
int sigemptyset(sigset_t *set);   // 清空信号集set
int sigfillset(sigset_t *set);    // 将所有信号加入信号集set中
int sigaddset(sigset_t *set, int signum);         // 将信号signum添加到信号集set中
int sigdelset(sigset_t *set, int signum);         // 将信号signum从信号集set中剔除
int sigismember(const sigset_t *set, int signum); // 测试信号signum是否在信号集set中

---------------------signal进程信号处理------------------
//信号 man -7 signal  
SIGINT ctrl + c
SIGOUIT ctrl + \


#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void func(int sig)
{
    printf("捕获到信号:%d\n", sig);
}

int main(int argc, char **argv)
{
    // 指定信号SIGINT关联函数
    signal(SIGINT, func);  //SIGINT ctrl + c 

    // 持续响应信号
    while(1)
        pause(); //等待信号

    return 0;
}

pause()函数：让进程暂停直到信号出现
头文件 #include <unistd.h>
函数： int pause(void);
函数说明： pause()会令目前的进程暂停(进入睡眠状态)，直到被信号(signal)所中断。
返回值：只返回-1
错误代码：EINTR 有信号到达中断了此函数。


gec@ubuntu:~$ man 7 signal

# 会得到类似如下的表格：
       ...
       Signal     Value     Action   Comment
       ──────────────────────────────────────────────────────────────────────
       SIGHUP        1       Term    Hangup detected on controlling terminal
                                     or death of controlling process
       SIGINT        2       Term    Interrupt from keyboard
       SIGQUIT       3       Core    Quit from keyboard
       SIGILL        4       Core    Illegal Instruction
       SIGABRT       6       Core    Abort signal from abort(3)
       SIGFPE        8       Core    Floating-point exception
       SIGKILL       9       Term    Kill signal
       SIGSEGV      11       Core    Invalid memory reference
       SIGPIPE      13       Term    Broken pipe: write to pipe with no
                                     readers; see pipe(7)
       ...
列表中的 Action 就是系统对信号的默认处理规则，默认规则如下：
Term 中断目标进程
Core 中断目标进程，且产生核心转储文件core。
Stop 暂停目标进程，直到收到信号SIGCONT
Cont 恢复目标进程运行
lgn  忽略信号

Term和Core都是中断程序，但Core处理方式还会产生转储文件core，core文件即程序在被中断的瞬间其内存映像的快照，用来给后续的调试提供追踪信息。但一般情况下系统是禁止生成所谓转储文件的，放开此项限制的命令是：

Ign是默认就会被忽略的信号，典型的例子是SIGCHLD，此信号是子进程在状态转变时（比如变成僵尸时）自动发给其父进程的信号。

SIGKILL和SIGSTOP这两个信号只能采取默认处理，不能阻塞、捕捉，也不能忽略。

# 查看当前系统对 core 文件的限制
gec@ubuntu:~$ ulimit -a
core file size          (blocks, -c) 0  # core 文件大小被限制为0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7635
max locked memory       (kbytes, -l) 16384
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 7635
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
gec@ubuntu:~$ 

# 将 core 文件的大小设置为“不限制”
gec@ubuntu:~$ ulimit -c unlimited

忽略信号
忽略信号就是直接将收到的信号丢弃：
int main()
{
	//忽略信号SIGINT
	signal(SIGINT,SIG_IGN);
}

------------扩展信号处理-------------
#include <signal.h>
函数：int sigaction(int signum, const struct sigaction *act,
                     struct sigaction *oldact);
 signum：要操作的信号。
 act：要设置的对信号的新处理方式。
 oldact：原来对信号的处理方式。
 返回值：0 表示成功，-1 表示有错误发生。

struct sigaction 类型用来描述对信号的处理，定义为：
 struct sigaction
 {
  void     (*sa_handler)(int);
  void     (*sa_sigaction)(int, siginfo_t *, void *);
  sigset_t  sa_mask;
  int       sa_flags;
  void     (*sa_restorer)(void);
 };

在这个结构体中，
    sa_handler 是一个函数指针，其含义与 signal 函数中的信号处理函数类似。
    sa_sigaction 则是另一个信号处理函数，它有三个参数，可以获得关于信号的更详细的信息。当 sa_flags 成员的值
包含了 SA_SIGINFO 标志时，系统将使用 sa_sigaction 函数作为信号处理函数，否则使用 sa_handler 作为信号处理
函数。在某些系统中，成员 sa_handler 与 sa_sigaction 被放在联合体中，因此使用时不要同时设置。
    sa_mask 成员用来指定在信号处理函数执行期间需要被屏蔽的信号，特别是当某个信号被处理时，它自身会被
自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生。
    sa_flags 成员用于指定信号处理的行为，它可以是一下值的“按位或”组合。
    re_restorer 成员则是一个已经废弃的数据域，不要使用。
sa_flags:
 ◆ SA_RESTART：使被信号打断的系统调用自动重新发起。
 ◆ SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。
 ◆ SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程。
 ◆ SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。
 ◆ SA_RESETHAND：信号处理之后重新设置为默认的处理方式。
 ◆ SA_SIGINFO：使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。

例子：
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <strings.h>

void func(int sig, siginfo_t *info, void *arg)
{
    // sig 是触发本函数的信号值
}
int main()
{
    struct sigaction act;
    bzero(&act,sizeof(act));  //sigemptyset(&act.sa_mask)

    // 指定函数响应函数
    act.sa_sigaction = func;   //void func(int sig, siginfo_t *info, void *arg)
    act.sa_flags |= SA_SIGINFO;  //void     (*sa_sigaction)(int, siginfo_t *, void *);

    sigaction(SIGINT, &act, NULL); //SIGINT ctrl + c 
    pause();
}

-----------编译过程中的文件-----------
.s 汇编语言源程序;  操作: 汇编
.S 汇编语言源程序;  操作: 预处理 + 汇编
.o 只编译不链接形成.o文件

----------------ssta()函数，获取文件状态------------
#include <sys/stat.h>
#include <uninstd.h>
函数：int stat(const char *file_name,struct stat *buf);
函数说明：stat()用来将参数file_name 所指的文件状态，复制到参数buf所指的结构中
返回值：执行成功则返回0，失败返回-1

下面是struct stat 内参数的说明：
struct stat {
    dev_t st_dev; //device 文件的设备编号
    ino_t st_ino; //inode 文件的i-node
    mode_t st_mode; //protection 文件的类型和存取的权限
    nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1.
    uid_t st_uid; //user ID of owner 文件所有者的用户识别码
    gid_t st_gid; //group ID of owner 文件所有者的组识别码
    dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号
    off_t st_size; //total size, in bytes 文件大小, 以字节计算
    unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小.
    u nsigned long st_blocks; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节.
    time_t st_atime; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变.
    time_t st_mtime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、 utime 和write 时才会改变
    time_t st_ctime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、 权限被更改时更新
};
参数 st_mode 定义了如下树种情况：
1、S_IFMT 0170000 文件类型的位遮罩
2、S_IFSOCK 0140000 scoket
3、S_IFLNK 0120000 符号连接
4、S_IFREG 0100000 一般文件
5、S_IFBLK 0060000 区块装置
6、S_IFDIR 0040000 目录
7、S_IFCHR 0020000 字符装置
8、S_IFIFO 0010000 先进先出
9、S_ISUID 04000 文件的 (set user-id on execution)位
10、S_ISGID 02000 文件的 (set group-id on execution)位
11、S_ISVTX 01000 文件的sticky 位
12、S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限
13、S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限
14、S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限
15、S_IRGRP 00040 用户组具可读取权限
16、S_IWGRP 00020 用户组具可写入权限
17、S_IXGRP 00010 用户组具可执行权限
18、S_IROTH 00004 其他用户具可读取权限
19、S_IWOTH 00002 其他用户具可写入权限
20、S_IXOTH 00001 其他用户具可执行权限上述的文件类型在 POSIX 中定义了检查这些类型的宏定义
21、S_ISLNK (st_mode) 判断是否为符号连接
22、S_ISREG (st_mode) 是否为一般文件
23、S_ISDIR (st_mode) 是否为目录
24、S_ISCHR (st_mode) 是否为字符装置文件
25、S_ISBLK (s3e) 是否为先进先出
26、S_ISSOCK (st_mode) 是否为socket 若一目录具有sticky 位 (S_ISVTX), 则表示在此目录下的文件只能 被该文件所有者、此目录所有者或root 来删除或改名.

错误代码
、ENOENT 参数file_name 指定的文件不存在
、ENOTDIR 路径中的目录存在但却非真正的目录
、ELOOP 欲打开的文件有过多符号连接问题, 上限为16 符号连接
、EFAULT 参数buf 为无效指针, 指向无法存在的内存空间
、EACCESS 存取文件时被拒绝
、ENOMEM 核心内存不足
、ENAMETOOLONG 参数file_name 的路径名称太长

范例：
#include <sys/stat.h>
#include <unistd.h>
int main() {
 struct stat buf;
 stat("/etc/passwd", &buf);
 printf("/etc/passwd file size = %d \n", buf.st_size);
 }
输出： /etc/passwd file size = 705

内核笔记=====================================================================================================================
账号网址
SMS-Activate 提供世界上大多数国家的虚拟号码，以便您可以在线接收带有确认代码的短信
https://sms-activate.org/getNumber  

GPT-4 API 开发人工智能
https://platform.openai.com/
密匙：sk-...X9m9
----------------------git-------------------------------
创建git仓库
git init

git下载Linux源码到仓库里
git status //查看哪些文件处于什么状态
git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git

-----------------------Linux--------------------------
内核通过唯一的进程标识值或PID来标识每一个进程
PID为一个数，pid_t为一个隐含类型  
查看系统中允许存在的进程的最大数目
/proc/sys/kernel/pid_max
可以通过修改这个最大进程数目，对于一般的桌面系统就足够了，
但一些大型的服务器可能需要更多的进程，这个值越小，转一圈就越快
==================
lseek():
	 repositions the file offset of the open file description
	 重新定位打开文件描述的文件偏移量
       associated with the file descriptor fd to the argument offset
	 与文件描述符fd关联到参数偏移量

与文件描述符fd关联到参数偏移量
头文件： #include <unistd.h>
用 法:	  off_t lseek(int fd, off_t offset, int whence);

EEK_SET 将读写位置指向文件头后再增加offset个位移量。
SEEK_CUR 以目前的读写位置往后增加offset个位移量。
SEEK_END 将读写位置指向文件尾后再增加offset个位移量。
当whence值为SEEK_CUR或SEEK_END时，参数offset允许负值的出现。

1) 将读写位置移到文件开头:
lseek（int fildes,0,SEEK_SET）；
2) 将读写位置移到文件尾:
lseek（int fildes，0,SEEK_END）；
3) 获取目前文件位置:
lseek（int fildes，0,SEEK_CUR）；

lseek()  
	allows  the  file  offset to be set beyond the end of the file
      (but this does not change the size of the  file).If  data is later
      written at this point, subsequent reads of the data in the gap 
	(a"hole") return null bytes ('\0') until data is actually written into
      the gap.
	允许将文件偏移量设置到文件末尾以外
	(但这不会改变文件的大小)。如果数据较晚
	此时写入，后续读取间隙中的数据
	(一个“hole”)返回0字节('\0')，直到数据真正写入
	的差距。

SEEK_DATA 
	将文件偏移量调整到文件中的下一个位置大于或等于包含数据的偏移量。
	如果Offset指向数据，则文件偏移量设置为偏移量。

return
success： 返回从文件开头以字节为单位测量的结果偏移位置
error  ：  -1 并且errno会提示错误原因
==========================


init 0  // 关机

========================
ldd 列出动态依赖性程序
例子：
ldd getpid
	linux-vdso.so.1 (0x00007ffcc96ee000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb48971a000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fb489925000)

===========================
gnu_get_libc_version() 确认运行的glibc版本
源码：
#include <gnu/libc-version.h>

const char *gnu_get_libc_version(void)l
			Returns pointer to null-terminated,statically allocated string containing GNU C library version number //返回指向以空结束的静态分配字符串的指针，该字符串包含GNU C库版本号
函数gnu_get_libc_version()返回一个指针，指向诸如 “2.12” 的字符串。

例子：
#include <stdio.h>
#include <gnu/libc-version.h>

const char *gnu_get_libc_version(void);

char* ptr = NULL;

int main()
{
    ptr = gnu_get_libc_version();
    printf("ptr = %s\n",ptr);
}
//结果
ptr = 2.31

==========================
perror()  会打印出其msg参数所指向的字符串，紧跟一条与当前errno值相对应的消息。
源码：
#include <stdio.h>

void perror(const char *msg);

例子：
fd = open(pathname,flags,mode);
if(fd == -1){
	perror("open");
	exit(EXIT_FAILURE);
}

由于perror()属于对语言敏感（locale-sensitive）的函数，故而错误描述中使用的都是本地语言。

// exit(EXIT_FAILURE)
EXIT_FAILURE和EXIT_SUCCESS是C语言头文件库中定义的一个符号常量，在vc++6.0下头文件stdlib.h中定义如：
#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

EXIT_FAILURE 可以作为exit()的参数来使用，表示没有成功的执行一个程序。
EXIT_SUCCESS作为exit()的参数来使用，表示成功地执行一个程序。

================
strerror() 会针对其errnum参数中所给定的错误号，返回相应的错误字符串。
源码：
#include <string.h>

char *strerror(int errnum);
			Returns pointer to error string corresponding to errnum //返回与errnum对应的错误字符串的指针

	由strerror()所返回的字符串可以是静态分配的，这意味着后续对strerror()的调用可能会覆灭该字符串。
	若无法识别errnum所含的错误编号，则strerror()会返回 “UnKnown error nnn.” 形式的字符串。在某些其他的实现中，在这种情况下，strerror()会返回NULL。
	由于strerror()属于对语言敏感（locale-sensitive）的函数，故而错误描述中使用的都是本地语言。

==============================




