-----------蓝牙音乐获取时间---------
handleAvrcpCtNotiPlaybackPosInd ind 手机上报 ，handleAvrcpCtGetPlayStatusCfm cfm是函数获取的
csr_bt_avrcp_down.c
start_get_play_status()

-----------c语言---------------------
atoi() 函数会扫描参数str字符串，跳过前面的空白字符(例如空格，tab缩进等，可以通过isspace()函数来检测)，
直到遇上数字或正负号才开始做转换，而再遇到非数字或字符串结束时('\0')才结束转换，并将结果返回
例子：
#include <stdio.h>
#include <stdlib.h>
int main()
{
    int i;
    char buffer[256];
    printf("请输入数字: \n");
    fgets(buffer,256,stdin);
    i = atoi(buffer);
    printf("i=%d\n",i);
    return 0;
}

-----------ubuntu-------------------
sudo apt install vim //更新vi编译器
sudo apt-get install net-tools //ubuntu中下载ipconfig(查看ip地址)
sudo mount -t vboxsf ***(共享文件夹名字) /mnt/share  //挂载共享文件夹
串口通信查看ttyUSB0
插入串口，打开设备下的USB的USB设置
添加USB选中插入的USB口
回到设备下的USB，选中刚刚添加的USB设备名称，有✔就成功添加
ls -a /dev/*USB*  //查看设备

----------------x20------------------
HCI_Link_Key_Notification //Link_key 文件查找
sc_db.db 文件用对比文件打开
spp  frame size 是数据大小 :RFCOMM 中Length：为数据长度
master 为 对方发送
slave 为 自己的发送

---------原生蓝牙linkey查看----------------
cat /data/misc/bluedroid/bt_config.conf


-------abd找密匙-------------------
win+r
cmd
adb devices
adb shell
cd /data/goc
ls
复制bt_snoop_20211114154926.cfa
exit
adb pull /data/goc/bt_snoop_20211114154926.cfa
start .
复制文件bt_snoop_20211114154926.cfa到没有中文路径下打开
查找HCI_Link_Key_Notification最后一个
确定密匙 Link_Key: 0x7a 64 1f 95 dc 6b f8 a8 86 43 0d fe 9d 11 92 f5


-------eclipse代码编译后板子上运行-------------------
adb connect  + ip地址 //连接板子(同一个局域网内)
win + r
cmd
dir  //查看报告
cd  Music\tcpadb\
adb root  //给root权限
adb remount  //重新挂载
adb push  .\s  /system/bin  //将服务器拷贝到板子的运行路径下去
adb push  .\c /system/bin  //将客户端拷贝到板子的运行路径下去
adb shell  //进去板子的控制系统,linux命令可用
cd  system/bin/  //进入运行路径
./s 3000        //运行代码
打开另一个命令窗口
adb shell  //进去板子的控制系统,linux命令可用
cd  system/bin/  //进入运行路径
ifconfig  //查看ip地址
./c 127.0.0.1 3000 
可以实现功能

adb pull system/bin  ./   //将板子的东西拷贝到当前文件夹
adb pull /usr/bin/gocsdk F:\ADB //将板子的东西拷贝到文件夹下
start .  //打开当前文件夹位置

adb connect 192.168.137.145   //网络adb使用方法
adb root
adb connect 192.168.137.145
adb remount
adb shell

在将代码push进去后可以直接运行
打开另一个终端输入下面命令
adb logcat -v time |grep goc
adb logcat -s goc   //查看日志运行状态
ps  -A  |grep gocsdk 查看进程是否运行
reboot 重启
adb logcat -s goc > F:/log/log.txt  //将日志保存在F盘中的文件中
echo AT#AA6091F3F9EBE6>/dev/goc_serial  手动开启功能
adb devices //查看当前设备
adb logcat -v time >log.txt //保存日志到log.txt
ctrl + z   //杀掉 logcat -s goc
logcat -v time   //以时间问单位打开日志
logcat |grep -Ei "goc"  //以goc筛选日志 
logcat |grep -Ei "adapter|blue|debug|androidruntime" //原生机器log
logcat |grep -Ei "adapter|AEE_AED|BLUE|androidruntime"

svc bluetooth disable
svc bluetooth enable

-----------设置自己的代码开机自启动将文件gocsdk.rc-------------
代码内容为：
service gocsdk /system/bin/gocsdk
    class main
    user root
    group root
    seclabel u:r:shell:s0
放在 /vendor/etc/init里

代码内容2：
service gocsdk_s /system/bin/gocsdk_s
    class main
    user root
    group root
    seclabel u:r:shell:s0
    setenv LD_LIBRARY_PATH /vendor/lib:/vendor/lib/hw
    disabled
on property:persist.sys.bt.goc=1
    start gocsdk
这个开机自启动,需要配置系统属性
查看属性值：
getprop  persist.sys.bt.goc
设置属性值：
setprop  persist.sys.bt.goc 1

----------------------Android12的remount失败--------------------
进入开发者模式，开启OEM模式
adb reboot  bootloader  
flashboot  flashing  unlock  //解锁操作
机器上操作，选择YES
flashboot  reboot
adb root
adb remount

-------------------段错误地址打印)查询段错误位置-------------------
logcat -v time -s DEBUG

打开项目使用的ndk -e + 出问题的obj文件的具体文件，由DEBUG段错误报错决定  + 错误编号(DEBUG) 
c:\android-ndk-r16b\toolchains\x86_64-4.9\prebuilt\windows-x86_64\bin\x86_64-linux-android-addr2line.exe
-e  c:\eclipse_daima\zhixing\obj\local\armeabi-v7a\gocsdk   002b4bf6

android-ndk-r25b\toolchains\llvm\prebuilt\windows-x86_64\bin

------------------MTK debug信息打开方式---------------------------
    setprop ro.vendor.aee.enforcing no
    setprop persist.vendor.aeev.core.dump enable      
    setprop persist.vendor.aeev.core.direct enable
    setprop persist.vendor.mtk.aee.mode 3
    setprop persist.vendor.mtk.aeev.mode 3
    setprop persist.vendor.mtk.aee.filter 0


logcat -s goc AEE_AED DEBUG system.err

-----------------设置gocsdk.so不报错--------------------------------
改arch/gocsdk/Android.mk
LOCAL_MODULE := gocsdk.so
C:\android-ndk-r25b\build\core\definitions.mk文件下的：

ifneq (,$$(filter %$$(TARGET_LIB_EXTENSION) %$$(TARGET_SONAME_EXTENSION),$$(LOCAL_MODULE_FILENAME)))
    $$(call __ndk_info,$$(LOCAL_MAKEFILE):$$(LOCAL_MODULE): LOCAL_MODULE_FILENAME must not contain a file extension)
    $$(call __ndk_error,Aborting)
endif
改为：
#ifneq (,$$(filter %$$(TARGET_LIB_EXTENSION) %$$(TARGET_SONAME_EXTENSION),$$(LOCAL_MODULE_FILENAME)))
#    $$(call __ndk_info,$$(LOCAL_MAKEFILE):$$(LOCAL_MODULE): LOCAL_MODULE_FILENAME must not contain a file extension)
#    $$(call __ndk_error,Aborting)
#endif

-----------------查看库文件的解析//看到安卓源文件-------------------
android-ndk-r25b-windows.zip\android-ndk-r25b\toolchains\llvm\prebuilt\windows-x86_64\bin>llvm-readelf.exe -aC + 有外部接口的库文件 > 输出的文件
例子：
android-ndk-r25b-windows.zip\android-ndk-r25b\toolchains\llvm\prebuilt\windows-x86_64\bin>llvm-readelf.exe -aC E:\32\libaudioclient.so > audioclient2.txt

---------------查看蓝牙声卡---------------------
cat /proc/asound/pcm

00-00: Loopback PCM : Loopback PCM : playback 8 : capture 8
00-01: Loopback PCM : Loopback PCM : playback 8 : capture 8
01-00: Playback_1 (*) :  : playback 1
01-01: Playback_12 (*) :  : playback 1
01-02: Playback_2 (*) :  : playback 1
01-03: Playback_5 (*) :  : playback 1
01-04: Capture_1 (*) :  : capture 1
01-05: Capture_2 (*) :  : capture 1
01-06: Capture_3 (*) :  : capture 1
01-07: Capture_4 (*) :  : capture 1
01-08: Capture_7 (*) :  : capture 1
01-09: Capture_Mono_1 (*) :  : capture 1
01-10: Hostless_LPBK (*) :  : playback 1 : capture 1
01-11: Hostless_FM (*) :  : playback 1 : capture 1
01-12: Hostless_Speech (*) :  : playback 1 : capture 1
01-13: Hostless_Sph_Echo_Ref (*) :  : playback 1 : capture 1
01-14: Hostless_Spk_Init (*) :  : playback 1 : capture 1
01-15: Hostless_ADDA_DL_I2S_OUT (*) :  : playback 1
01-30: BTCVSD snd-soc-dummy-dai-30 :  : playback 1 : capture 1

30为蓝牙声卡
--------------------编译android源码步骤---------------------------
liugenlin@server:mt67_68xx_12.0$ cat ReadMe.txt
//首先进入所需工程目录
//mt67_68xx_12.0
1.source build/envsetup.sh
2.lunch 83
3.make -j12 | tee build.log 2&>1&

----------------关闭SElinux权限------------------------
getenforce //查看权限
setenforce 0


-----------------Android系统库文件保存位置-----------------------
/system/etc/public.libraries.txt
非Android系统库，会出现概率链接不到。


-------eclipse代码编译后覆盖板子上的原代码后运行-------------------
将自己的代码替换掉 /vendor/bin 目录下的 gocsdk    (ls -l goc*)可以查找
重启后就可以使用自己的代码



-------eclipse代码编译报错总结-------------------
1. ndk环境23不支持，后安装18可以编译不报错
2. ndk 编译链报错
问题是：
Android NDK: NDK Application 'local' targets unknown ABI(s): armeabi - hf
Android NDK: Please fix the APP_ABI definition in C:/eclipse_daima/jni/Application.mk
C:/linux-ndk-r12b/build//../build/core/setup-app.mk:120: *** Android NDK : Aborting
"C:/linux-ndk-r12b/ndk-build.cmd CUSTOMER=T3_Linux_BF440_HongYing_LIANXI_zj -B -j8 -B ...
解决办法:
是因为代码里面的cnfig.mk 编译中的APP_ABI:= armeabi-hf 没有对应ndk编译链
去更改为 APP_ABI:= armeabi 就能成功编译
3.gocsdk明明在路径下却报错说没有文件和目录
可能的原因有: 没有权限，可以 chmod  777 gocsdk 
可能有编译链有问题，比如使用软浮点的车机却使用了硬浮点的代码，这个时候就需要重新更改编译链


------------230日志打不开-----------------------
goc_config.c 中 is_goc_debug TRUE 打开后没有作用可检查

common.mk文件中
	DEBUG_PORT     := 1
//             DEBUG_PORT  1 是输出跟打印同一个串口输出,
//                                     2 是打印跟输出串口不一样

//更改后可能存在问题，功能不能实现可以更改
	Makefile 中更改为 HAS_SPLITE_UART := 0
                 //HAS_SPLITE_UART是否将串口和打印分开 1分开,0是不分开


-------------BLE--------------------
0  ble做主机要求
 1AT#LC0,[uuid:36][role:1]   此指令为注册ble蓝牙服务
	uuid：目前固定为00000000-0000-0000-0000-000000002002
	role: 为ble 的角色   0：做从   1：做主
	eg:AT#LC0,00000000-0000-0000-0000-0000000020021
    状态回复：
      LR0,[gattid],[status],[uuid]
	status:注册状态    0 ：注册成功   1 注册失败
	eg:LR0,327701,0,00000000-0000-0000-0000-000000002002

2AT#LS1 此指令是扫描ble
	eg:AT#LS1

    状态回复：
      LP,[evt_type],[addr_type],[str_addr],[primary_phy],[secondary_phy],[advertising_sid],[tx_power],[rssi],[periodic_adv_int],[data_len],[data]
//ble4.2广播数据类型 https://blog.csdn.net/freemote/article/details/119345553
LP70013,00,F44EFD0011CD,01,00,FF,7F,C3,0000,1F,020106050312180F180319800111094274566F696365417373697374616E74
1F  020106050312180F180319800111094274566F696365417373697374616E74   //1F:31 62
020106 050312180F18 03198001 11 09 42 74 56 6F 69 63 65 41 73 73 69 73 74 61 6E 74	
					     B  t  V  o  i  c  e  A  s  s  i  s  t  a  n  t  //16+1 = 17


primary_phy：主要的phy
secondary_phy：次要的phy
tx_power：发射功率
rssi： 接收信号强度指示器
advertising_sid：广告的sid
ble做主只需要注册ble蓝牙服务

-----------------------------------------------------------------

1  新增ble 做从机需求
相关指令：
 1AT#LC0,[uuid:36][role:1]   此指令为注册ble蓝牙服务
	uuid：目前固定为00000000-0000-0000-0000-000000002002
	role: 为ble 的角色   0：做从   1：做主
	eg:AT#LC0,00000000-0000-0000-0000-0000000020020
    状态回复：
      LR0,[gattid],[status],[uuid]
	status:注册状态    0 ：注册成功   1 注册失败
	eg:LR0,327701,0,00000000-0000-0000-0000-000000002002
 
 2 AT#LC12,[gattid],[servicetype:1],[serveruuid] 此指令为添加ble 主服务
	gattid:注册不了服务时，返回的id
	servicetype:需要注册的主服务的类型，1: 16位的uuid,  2: 32位的uuid, 3: 128位uuid(2,3 协议栈暂时添加)
	serveruuid：要使用的ble 主要服务的uuid  
	eg:AT#LC12,327701,1,FFE0

3 AT#LC13,[gattid],[servicetype:1],[properties],[valuelenth],[value],[charauuid] 此指令为添加ble 特征服务（Characteristic则是GATT profile中最基本的数据单位，由一个Properties、一个Value、一个或者多个Descriptor组成）
	gattid:注册不了服务时，返回的id
	servicetype:需要注册的主服务的类型，1: 16位的uuid,  2: 32位的uuid, 3: 128位uuid(2,3 协议栈暂时添加)
	properties:特征服务的属性值，常用的有 read:0x02  write:0x08 notify:0x10
	valuelenth：特征值长度
	value：特征值 （可以没有特征值）
	charauuid：特征uuid
	eg:AT#LC13,327701,1,26,0,,0001

 4 AT#LC11,[gattid],[eventmask]  此指令为允许gatt 订阅事件
	eventmask: 0 没有订阅事件，1 订阅物理链路状态事件， 2 订阅白名单改变事件， 3 连接参数更新等； 默认为0
	eg：AT#LC11,327701,0

 5 AT#LC15,[gattid] 此指令为生成上面所添加的所有服务
	eg:AT#LC15,327701  

   状态回复：
    LR3,[gattid],[connectind],[index],[attribute_type],[length],[starthandle],[endhandle]
	eg:LR3,1048576,2,3,1018,16,E2FF,1017

 6 AT#LC10,[gattid]  此指令为注销ble
	eg:eg:AT#LC10,327701  

 7 AT#LC16,[gattid],[[endhandle]],[write_type],[auth_req],[data_len],[data]  此指令为发送数据给ble设备
	[endhandle]:被通知的特征值句柄，为0的情况下，协议栈会自动查找handle,当注册多个属性时，需要指定handle
	write_type: 默认为0
	auth_req:默认为0
	data_len: 发送的数据长度
	data: 发送的数据
	eg:AT#LC16,327701,1017,0,0,3,123

8 收到ble  notify 数据的状态
	LR8,[gattid],[connect_id],[addr:12],[handle],[len],[data],[is_notify]
	eg:LR8,327701,1048576,68BFAF520B79,1015,7,1234568,0

9 LR1,[gattid],[connectid],[status],[addr:12]   //ble 连接成功状态回调
	eg:LR1,196628,1048576,0,5C17092A5B6F

10 LR9,[gattid],[connectid],[status],[addr:12]   //ble 断开状态回调
	eg:LR9,196628,1048576,0,5C17092A5B6F
从机ble 按上面 1 2 3 4 5 步骤操作后，手机就可以连接指定ble 服务 进行数据交互

-------------烧入工具--------------------
dld_main 账号密码为 1，1


-------------下载apk软件命令------------
adb  install -r   +  .apk


-----------内置协议栈--------------------
内置协议栈都是原生的，运行自己的代码时，需要将机器原生的蓝牙干掉，
不然自己的代码不能运行起来

-------------加密步骤--------------------
加密需要设置3个参数
goc_config.c里
set_databasepath("/data/goc");  //需要客户确认
profile_set_enc_pwdtype(0xb1);  //是需要代总提供更改的
const char* get_customer_id()
{
	return "GOC-TEST";
}  // 是需要提供给代总，调试的时候使用GOC-TEST。

一般获取唯一识别码的方法
getprop |grep serial

-------------SOCKET通信----------------
进程间通信
#include <sys/socket.h>
#include <sys/un.h>

//PF_UNIX用来在同一机器上的提供有效的进程间通讯
unix_socket = socket(PF_UNIX,type,0)   
error = socketpair(PF_UNIX, type, 0, int *sv);

---------------Android系统中获取设备信息------------
getprop命令：

查询Android设备的所有配置信息
adb shell getprop
在所列出的配置当中，以ro开头的是只读属性

查看Android设备单个配置信息
adb shell getprop  <prop-name>
例：查看单板的信息
adb shell getprop ro.product.board
查看进程默认虚拟机最大堆内存
adb shell getprop dalvik.vm.heapgrowthlimit

setprop对Android系统进行配置设置(ro类型不能被设置)
setprop <prop-name> <value>
例：修改进程默认分配的可以使用堆内存大小:
adb shell setprop dalvik.vm.heapgrowthlimit 128m

-----------------属性设置----------------
hci权限：
setprop persist.bluetooth.btsnoopenable true

getprop persist.bluetooth.btsnoopenable
全log：
setprop get_log_level true
getprop get_log_level

setprop e_log_level_info true
getprop e_log_level_info 

配置录音文件:
setprop persist.sys.bt.audio  true
----------------查看安卓版本-------------
getprop | grep sdk


-----------------后台启动软件------------
gocskd&

-----------------保存开机日志----------------
dmesg命令默认的时间显示是从开机到log记录的时间
adb shell dmesg > demsg.txt
start .  ///注意这里有点

----------------查看机器可执行文件----------
which gocsdk

---------------系统驱动----------------
查看系统驱动命令：
	lsmod
卸载系统驱动：
	rmmod  + 驱动名称

------------md5码---------------------
md5sum  libGbtsDriver.so

----------------内核日志-------------------
把它重定向到文件
sh -c /mnt/nfs/gocsdk.so 2 >&1 | tee /opt/pub/bt_stack.txt&


---------------配置环境变量---------------
export LD_LIBRARY_PATH=/vendor/lib:/vendor/lib/hw
export ld_library_path

---------------Android音频底层调试工具(tinymix,tinypaly,tinycap)----------
tinymix可以查看系统的音频控件
例子:
tinymix -D I 176 0
tinyplay 可以直接进行播放wav格式文件
例子:
tinyplay  xxx.wav

tinycap 可以录音
例子:
tinycap xxx.wav

----------------多台adb设备进入方法--------------------
adb -s + addr + shell

-------------广播----------------------

-------------上传代码-------------------
桌面界面右键SVN Checkout
选中目标文件夹，右键选中Create folder新建文件夹
将新建文件夹下载下来，将要上传的文件复制进入下载的新建文件夹
全选右键TortoiseSVN中的add
add成功后，右键SVN Commit 输入更新的日志，点击ok开始上传，成功后点击ok就完成上传

-------------eclipse快捷键----------
ctrl + O (查看函数）
ctrl + shift + f （函数对齐）

------------旧协议栈的gocsdk.so无法下载--------
将gocsdk.so改为gocsdk.exec

-------------建立同步链接--------------------
命令：Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。
当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。

例子： cd /system/lib
	ln -s /data/goc/libGbtsDriver.so  libGbtsDriver.so


------------iinker-------------------
linker主要作用：加载可执行程序依赖的库；查找修改被引用的符号（称为符号解析或者重定向）。

-----------蓝牙启动流程----------------
代码启动会去打印模块型号（get_module_name（））
然后会去打开伪终端ptmx
#include <stdlib.h>
int grantpt(int filedes);
int unlockpt(int filedes);
两个函数的返回值: 若成功则返回0，若出错则返回-1

grantpt函数提供的功能：在伪终端从设备可被使用之前，必须设置它的权限，使得应用程序可以访问它。它把从设备节点的用户ID设置为调用者的实际用户ID, 设置其组ID为一非指定值，通常是可以访问该终端设备的组。将权限设置为：对单个所有者是读写，对组所有者是写（0620）。
unlockpt函数用于准予对伪终端从设备的访问，从而允许应用程序打开该设备。阻止其他进程打开从设备，使得建立该设备的应用程序有机会在使用主、从设备之前正确地初始化这些设备。

ptsname()函数返回与文件描述符fd引用的主设备对应的从伪终端设备的名称。
ptsname_r()函数是ptsname()的可重入等价函数。它返回从伪终端设备的名称，作为buf指向的缓冲区中的一个以空字符结尾的字符串。buflen参数指定了可用的字节数在缓冲区。

symlink(target,link)创建一个从指定名称连接的现存目标文件开始的符号链接

-----------------hid------------
hidh = hid host  
hidd = hid devices

--------------手机取消配对继续弹框问题------
gap_app.c
void handleGapBondInd
else{
	ap_send_pair_state(&deviceAddr,cod,instData->scVar.name,0,1);
	//修改点
	dm_acl_disconnect_by_addr(deviceAddr);
}
	memset(instData->passkey_singal,0,sizeof(instData->passkey_singal));
}

csr_bt_gap_app_sc.c
static void csrBtScRebondIndFunc
//修改点
// handleGapREbondInd(cod,deviceAddr,deviceName,addressType);
dm_acl_disconnect_by_addr(deviceAddr);

-------------将16k音频文件转换为8k音频文件------------
jni/apm/apm.cc
extern "C" unsigned int apm_onlyAnalyzeReverse(){
	
	if(sample_rate != APM_SAPLE_RATE){
		resampler_new() //
		resampler_resample()
	}
}

-------------小系统riscv Linux的ndk修改------------
1.
目录/riscv64-unknown-linux-gnu-10.2.0 是需要自己创建，从原有的基础上复制 //格式为：riscv64-unknown-linux-gnu-（+版本号）
/android-ndk-r12b/build/core/toolchains/riscv64-unknown-linux-gnu-10.2.0/config.mk
TOOLCHAIN_ARCH := riscv_64  //对应代码 config.mk文件，名字可自己定义
TOOLCHAIN_ABIS := riscv_64
2.
将编译链Ubuntu里解压，
/android-ndk-r12b/toolchains/riscv64-unknown-linux-gnu-10.2.0/prebuilt/linux-x86_64/里替换解压的文件
3.
代码编译，报什么错，看需要修改什么


-------------查看软件需要链接的库文件----------
arm-linux-androideabi-readelf -d gocsdk.so
arm-linux-androideabi-readelf -d libGbtsTask.so

------------Android手机连接adb不弹出允许调试窗口---------
adb root 
adb: unable to connect for root: device unauthorized.
This adb server's $ADB_VENDOR_KEYS is not set
Try 'adb kill-server' if that seems wrong.
Otherwise check for a confirmation dialog on your device.
解决方法：
adb kill-server
adb start-server
再重新插拔usb线


-----------Android手机获取hci日志和所有错误报告------------
adb bugreport .

小米手机  *#*#5959#*#*  路径：/sdcard/MIUI/debug_log/

-------------原生蓝牙--------------------
使用am start命令启动android apk应用程序
 am start -n com.android.settings/.Settings

--------------Android系统设置机器内置时间-----------
adb root
adb remount
adb shell
date //查看机器时间
date 2023-06-14 //设置机器日期
date 06141157.00  //设置时间为 6月14日11点57分00秒 


--------------查看Android系统分区-----------------
mount


--------------linux的录音播放程序代码基于alsa------------------
#include <stdio.h>
#include <stdlib.h>
#include <alsa/asoundlib.h>

#define BUFFER_SIZE 1024

int main() {
    int err;
    unsigned int sample_rate = 44100;
    unsigned int channels = 2;
    snd_pcm_t *capture_handle, *playback_handle;
    snd_pcm_hw_params_t *hw_params;

    // 打开默认录音设备
    err = snd_pcm_open(&capture_handle, "default", SND_PCM_STREAM_CAPTURE, 0);
    if (err < 0) {
        printf("无法打开录音设备: %s\n", snd_strerror(err));
        return 1;
    }

    // 打开默认播放设备
    err = snd_pcm_open(&playback_handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
    if (err < 0) {
        printf("无法打开播放设备: %s\n", snd_strerror(err));
        return 1;
    }

    // 分配硬件参数对象
    err = snd_pcm_hw_params_malloc(&hw_params);
    if (err < 0) {
        printf("无法分配硬件参数对象: %s\n", snd_strerror(err));
        return 1;
    }

    // 初始化硬件参数对象
    err = snd_pcm_hw_params_any(capture_handle, hw_params);
    if (err < 0) {
        printf("无法初始化硬件参数: %s\n", snd_strerror(err));
        return 1;
    }

    // 设置硬件参数：采样率、声道数和格式
    err = snd_pcm_hw_params_set_rate_near(capture_handle, hw_params, &sample_rate, 0);
    if (err < 0) {
        printf("无法设置采样率: %s\n", snd_strerror(err));
        return 1;
    }
    err = snd_pcm_hw_params_set_channels(capture_handle, hw_params, channels);
    if (err < 0) {
        printf("无法设置声道数: %s\n", snd_strerror(err));
        return 1;
    }

    // 将硬件参数应用到录音设备
    err = snd_pcm_hw_params(capture_handle, hw_params);
    if (err < 0) {
        printf("无法设置硬件参数到录音设备: %s\n", snd_strerror(err));
        return 1;
    }

    // 将硬件参数应用到播放设备
    err = snd_pcm_hw_params(playback_handle, hw_params);
    if (err < 0) {
        printf("无法设置硬件参数到播放设备: %s\n", snd_strerror(err));
        return 1;
    }

    // 分配缓冲区
    char *buffer = (char *)malloc(BUFFER_SIZE * snd_pcm_format_width(SND_PCM_FORMAT_S16_LE) / 8 * channels);

    // 开始录音和播放
    while (1) {
        // 从录音设备读取音频数据
        err = snd_pcm_readi(capture_handle, buffer, BUFFER_SIZE);
        if (err < 0) {
            printf("读取录音数据失败: %s\n", snd_strerror(err));
            break;
        }

        // 播放音频数据
        err = snd_pcm_writei(playback_handle, buffer, err);
        if (err < 0) {
            printf("播放音频数据失败: %s\n", snd_strerror(err));
            break;
        }
    }

    // 释放资源
    free(buffer);
    snd_pcm_hw_params_free(hw_params);
    snd_pcm_close(capture_handle);
    snd_pcm_close(playback_handle);

    return 0;
}

/*这段代码首先使用snd_pcm_open函数打开默认的录音设备和播放设备，
然后使用snd_pcm_hw_params_malloc函数分配硬件参数对象。接下来，代码使用snd_pcm_hw_params_any函数初始化硬件参数对象，
并使用snd_pcm_hw_params_set_rate_near和snd_pcm_hw_params_set_channels函数设置采样率和声道数。
然后，通过snd_pcm_hw_params函数将硬件参数应用到录音设备和播放设备。
代码中的主循环使用snd_pcm_readi函数从录音设备读取音频数据，并使用snd_pcm_writei函数将音频数据写入播放设备进行播放。循环将一直运行，直到发生错误。
最后，代码释放缓冲区和硬件参数对象，并使用snd_pcm_close函数关闭录音设备和播放设备。
请注意，此示例代码非常简化，并且没有包含错误处理的完整逻辑。
在实际应用中，您应该添加适当的错误处理代码以及其他功能，例如录音时间限制、静音检测等。*/



------------.mk 文件中，= 、:= 、?= 、+= 的区别----------------
= 是最基本的赋值
:= 是覆盖之前的值
?= 是如果没有被赋值过就赋予等号后面的值
+= 是添加等号后面的值

而 = 与 := 的区别在于，= 会在makefile 展开后再决定变量的值，即最后被指定的值

eg：

            x = foo
            y = $(x) bar
            x = xyz

      在上例中，y的值将会是 xyz bar ，而不是 foo bar 。

而:= 表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。
在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。

-----------------------lsof---------------------------------
lsof是List open File获取被进程打开文件的信息。
lsof命令可以查看所有已经打开了的文件，比如: 普通文件，目录，特殊的块文件，管道，socket套接字，设备，Unix域套接字等等，同时，它还可以结合 grep 以及 ps 命令进行更多的高级搜索

----------------------并发程序--------------------------
#include <sys/wait.h>
pid_t wait(int * statloc);
pid_t waitpid(pid_t pid,int *statloc,int options);

pid_t wait(int * statloc);
主要功能：
阻塞当前进程
等待其子进程退出并回收其系统资源
解析：
如果当前进程没有子进程，则该函数立即返回。
如果当前进程有不止1个子进程，则该函数会回收第一个变成僵尸态的子进程的系统资源。
子进程的退出状态（包括退出值、终止信号等）将被放入wstatus所指示的内存中，若wstatus指针为NULL，则代表当前进程放弃其子进程的退出状态。

#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <sys/wait.h> 

int main()
{
    if(fork() == 0)
    {
        printf("[%d]: 我将在3秒后正常退出，退出值是88\n", getpid());

        for(int i=3; i>=0; i--)
        {
            fprintf(stderr, " ======= %d =======%c", i, i==0?'\n':'\r');
            sleep(1);
        }

        exit(88);
    }

    else
    {
        printf("[%d]: 我正在试图回收子进程的资源...\n", getpid());

        int status;
        wait(&status);

        if(WIFEXITED(status))
        {
            printf("[%d]: 子进程正常退出了，其退出值是：%d\n", getpid(), WEXITSTATUS(status));
        }
    }
}
执行结果：
gec@ubuntu:$ ./a.out
[3611]: 我正在试图回收子进程的资源...
[3612]: 我将在3秒后正常退出，退出值是88
 ======= 0 =======
[3611]: 子进程正常退出了，其退出值是：88
gec@ubuntu:$ 

pid_t waitpid(pid_t pid,int *statloc,int options);

pid:
	 < -1: 取该 pid 的绝对值，如果任何子进程的进程组ID等于该值，则该进程组的任一子进程中的进程状态发生变化，都会触发`waitpid`的回调;
        == -1: 监听范围扩大到任意子进程，也就是 wait(status)；
        ==  0: 监听进程组ID和父进程一样的子进程；
         >  0: 监听该pid的子进程；

options:
	WNOHANG： 调用时，指定的 pid 仍未结束运行，则 wait 立即返回 0；
        WUNTRACED： 当子进程被暂停时，则立即返回子进程的 pid;
        WCONTINUED: 当被暂停的子进程，又被信号恢复时，则立即返回子进程的pid；

------------------信号集操作函数组----------------
// 信号集操作函数组
#include <signal.h>
int sigemptyset(sigset_t *set);   // 清空信号集set
int sigfillset(sigset_t *set);    // 将所有信号加入信号集set中
int sigaddset(sigset_t *set, int signum);         // 将信号signum添加到信号集set中
int sigdelset(sigset_t *set, int signum);         // 将信号signum从信号集set中剔除
int sigismember(const sigset_t *set, int signum); // 测试信号signum是否在信号集set中

---------------------signal进程信号处理------------------
//信号 man -7 signal  
SIGINT ctrl + c
SIGOUIT ctrl + \


#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void func(int sig)
{
    printf("捕获到信号:%d\n", sig);
}

int main(int argc, char **argv)
{
    // 指定信号SIGINT关联函数
    signal(SIGINT, func);  //SIGINT ctrl + c 

    // 持续响应信号
    while(1)
        pause(); //等待信号

    return 0;
}

pause()函数：让进程暂停直到信号出现
头文件 #include <unistd.h>
函数： int pause(void);
函数说明： pause()会令目前的进程暂停(进入睡眠状态)，直到被信号(signal)所中断。
返回值：只返回-1
错误代码：EINTR 有信号到达中断了此函数。


gec@ubuntu:~$ man 7 signal

# 会得到类似如下的表格：
       ...
       Signal     Value     Action   Comment
       ──────────────────────────────────────────────────────────────────────
       SIGHUP        1       Term    Hangup detected on controlling terminal
                                     or death of controlling process
       SIGINT        2       Term    Interrupt from keyboard
       SIGQUIT       3       Core    Quit from keyboard
       SIGILL        4       Core    Illegal Instruction
       SIGABRT       6       Core    Abort signal from abort(3)
       SIGFPE        8       Core    Floating-point exception
       SIGKILL       9       Term    Kill signal
       SIGSEGV      11       Core    Invalid memory reference
       SIGPIPE      13       Term    Broken pipe: write to pipe with no
                                     readers; see pipe(7)
       ...
列表中的 Action 就是系统对信号的默认处理规则，默认规则如下：
Term 中断目标进程
Core 中断目标进程，且产生核心转储文件core。
Stop 暂停目标进程，直到收到信号SIGCONT
Cont 恢复目标进程运行
lgn  忽略信号

Term和Core都是中断程序，但Core处理方式还会产生转储文件core，core文件即程序在被中断的瞬间其内存映像的快照，用来给后续的调试提供追踪信息。但一般情况下系统是禁止生成所谓转储文件的，放开此项限制的命令是：

Ign是默认就会被忽略的信号，典型的例子是SIGCHLD，此信号是子进程在状态转变时（比如变成僵尸时）自动发给其父进程的信号。

SIGKILL和SIGSTOP这两个信号只能采取默认处理，不能阻塞、捕捉，也不能忽略。

# 查看当前系统对 core 文件的限制
gec@ubuntu:~$ ulimit -a
core file size          (blocks, -c) 0  # core 文件大小被限制为0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7635
max locked memory       (kbytes, -l) 16384
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 7635
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
gec@ubuntu:~$ 

# 将 core 文件的大小设置为“不限制”
gec@ubuntu:~$ ulimit -c unlimited

忽略信号
忽略信号就是直接将收到的信号丢弃：
int main()
{
	//忽略信号SIGINT
	signal(SIGINT,SIG_IGN);
}

------------扩展信号处理-------------
#include <signal.h>
函数：int sigaction(int signum, const struct sigaction *act,
                     struct sigaction *oldact);
 signum：要操作的信号。
 act：要设置的对信号的新处理方式。
 oldact：原来对信号的处理方式。
 返回值：0 表示成功，-1 表示有错误发生。

struct sigaction 类型用来描述对信号的处理，定义为：
 struct sigaction
 {
  void     (*sa_handler)(int);
  void     (*sa_sigaction)(int, siginfo_t *, void *);
  sigset_t  sa_mask;
  int       sa_flags;
  void     (*sa_restorer)(void);
 };

在这个结构体中，
    sa_handler 是一个函数指针，其含义与 signal 函数中的信号处理函数类似。
    sa_sigaction 则是另一个信号处理函数，它有三个参数，可以获得关于信号的更详细的信息。当 sa_flags 成员的值
包含了 SA_SIGINFO 标志时，系统将使用 sa_sigaction 函数作为信号处理函数，否则使用 sa_handler 作为信号处理
函数。在某些系统中，成员 sa_handler 与 sa_sigaction 被放在联合体中，因此使用时不要同时设置。
    sa_mask 成员用来指定在信号处理函数执行期间需要被屏蔽的信号，特别是当某个信号被处理时，它自身会被
自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生。
    sa_flags 成员用于指定信号处理的行为，它可以是一下值的“按位或”组合。
    re_restorer 成员则是一个已经废弃的数据域，不要使用。
sa_flags:
 ◆ SA_RESTART：使被信号打断的系统调用自动重新发起。
 ◆ SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。
 ◆ SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程。
 ◆ SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。
 ◆ SA_RESETHAND：信号处理之后重新设置为默认的处理方式。
 ◆ SA_SIGINFO：使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。

例子：
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <strings.h>

void func(int sig, siginfo_t *info, void *arg)
{
    // sig 是触发本函数的信号值
}
int main()
{
    struct sigaction act;
    bzero(&act,sizeof(act));  //sigemptyset(&act.sa_mask)

    // 指定函数响应函数
    act.sa_sigaction = func;   //void func(int sig, siginfo_t *info, void *arg)
    act.sa_flags |= SA_SIGINFO;  //void     (*sa_sigaction)(int, siginfo_t *, void *);

    sigaction(SIGINT, &act, NULL); //SIGINT ctrl + c 
    pause();
}

-----------编译过程中的文件-----------
.s 汇编语言源程序;  操作: 汇编
.S 汇编语言源程序;  操作: 预处理 + 汇编
.o 只编译不链接形成.o文件

----------------ssta()函数，获取文件状态------------
#include <sys/stat.h>
#include <uninstd.h>
函数：int stat(const char *file_name,struct stat *buf);
函数说明：stat()用来将参数file_name 所指的文件状态，复制到参数buf所指的结构中
返回值：执行成功则返回0，失败返回-1

下面是struct stat 内参数的说明：
struct stat {
    dev_t st_dev; //device 文件的设备编号
    ino_t st_ino; //inode 文件的i-node
    mode_t st_mode; //protection 文件的类型和存取的权限
    nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1.
    uid_t st_uid; //user ID of owner 文件所有者的用户识别码
    gid_t st_gid; //group ID of owner 文件所有者的组识别码
    dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号
    off_t st_size; //total size, in bytes 文件大小, 以字节计算
    unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小.
    u nsigned long st_blocks; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节.
    time_t st_atime; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变.
    time_t st_mtime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、 utime 和write 时才会改变
    time_t st_ctime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、 权限被更改时更新
};
参数 st_mode 定义了如下树种情况：
1、S_IFMT 0170000 文件类型的位遮罩
2、S_IFSOCK 0140000 scoket
3、S_IFLNK 0120000 符号连接
4、S_IFREG 0100000 一般文件
5、S_IFBLK 0060000 区块装置
6、S_IFDIR 0040000 目录
7、S_IFCHR 0020000 字符装置
8、S_IFIFO 0010000 先进先出
9、S_ISUID 04000 文件的 (set user-id on execution)位
10、S_ISGID 02000 文件的 (set group-id on execution)位
11、S_ISVTX 01000 文件的sticky 位
12、S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限
13、S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限
14、S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限
15、S_IRGRP 00040 用户组具可读取权限
16、S_IWGRP 00020 用户组具可写入权限
17、S_IXGRP 00010 用户组具可执行权限
18、S_IROTH 00004 其他用户具可读取权限
19、S_IWOTH 00002 其他用户具可写入权限
20、S_IXOTH 00001 其他用户具可执行权限上述的文件类型在 POSIX 中定义了检查这些类型的宏定义
21、S_ISLNK (st_mode) 判断是否为符号连接
22、S_ISREG (st_mode) 是否为一般文件
23、S_ISDIR (st_mode) 是否为目录
24、S_ISCHR (st_mode) 是否为字符装置文件
25、S_ISBLK (s3e) 是否为先进先出
26、S_ISSOCK (st_mode) 是否为socket 若一目录具有sticky 位 (S_ISVTX), 则表示在此目录下的文件只能 被该文件所有者、此目录所有者或root 来删除或改名.

错误代码
、ENOENT 参数file_name 指定的文件不存在
、ENOTDIR 路径中的目录存在但却非真正的目录
、ELOOP 欲打开的文件有过多符号连接问题, 上限为16 符号连接
、EFAULT 参数buf 为无效指针, 指向无法存在的内存空间
、EACCESS 存取文件时被拒绝
、ENOMEM 核心内存不足
、ENAMETOOLONG 参数file_name 的路径名称太长

范例：
#include <sys/stat.h>
#include <unistd.h>
int main() {
 struct stat buf;
 stat("/etc/passwd", &buf);
 printf("/etc/passwd file size = %d \n", buf.st_size);
 }
输出： /etc/passwd file size = 705

----------------------共享内存SHM实现读写-------------
创建或打开SHM对象
#include <sys/ipc.h>
#include <sys/shm.h>
函数：int shmget(key_t key,size_t size,int shmflg);
参数：key:SHM对象键值，size：共享内存大小，
shmflg：创建模式和权限
    IPC_CREAT：如果key对应的共享内存不存在，则创建SHM对象
    IPC_EXCL：如果该key对应的共享内存已存在，则报错
        权限与文件创建open类似，用八进制表示
函数说明：SHM对象的创建或者打开需要唯一的键值标识，并且需要指定内存的大小尺寸
返回值：成功返回SHM对象ID，失败返回-1，错误原因存于errno中

错误代码：
EINVAL：参数size小于SHMMIN或大于SHMMAX
EEXIST：预建立key所指的共享内存，但已经存在
EIDRM：参数key所指的共享内存已经删除
ENOSPC：超过了系统允许建立的共享内存的最大值(SHMALL)
ENOENT：参数key所指的共享内存不存在，而参数shmflg未设IPC_CREAT位
EACCES：没有权限
ENOMEM：核心内存不足
···································································
映射/解除映射SHM对象
#include <sys/types.h>
#include <sys/shm.h>
函数：void *shmat(int shmid,const void *shmaddr/*一般为NULL*/,int shmflg);
函数说明：将创建好的共享内存连接到某个进程，并指定内存空间
参数：shmid：指定的共享内存的ID，shmaddr：指定映射后的地址，因为是虚拟地址，分配的原则要兼顾诸如段对齐、权限分配等问题，因此用户进程是无法指定的，只能由系统自动分配，因此此参数一般为NULL，表示交由系统来自动分配。
shmflg：
    0：默认，代表共享内存可读可写。
        SHM_RDONLY：代表共享内存只读。
返回值：共享内存映射后的虚拟地址入口。
正确映射之后，命令ipcs -m查看SHM对象时，可从nattch列中看到已映射进程个数
···································································
解除映射
#include <sys/types.h>
#include <sys/shm.h>
函数：int shmdt(const void *shmaddr);
函数说明：使用完SHM对象后，需要将其跟进程解除关联关系，即解除映射
···································································
删除共享内存段
#include <sys/ipc.h>
#include <sys/shm.h>
函数：int shmctl(int shmid,int cmd,struct shmid_ds *buf);
参数：shmid：指定的共享内存的ID，buf：用来存放共享内存信息的结构体
cmd：
    IPC_STAT：获取共享内存 的一些信息，放入shmid_ds{ }中
    IPC_SET：将 buf 中指定的信息，设置到本共享内存中
    IPC_RMID：删除指定的共享内存，此时第三个参数 buf 将被忽略
···································································
实例：
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>

#define SHM_SIZE 1024  // 共享内存大小

int main() {
    int shm_id;
    char *shared_memory;
    key_t key = ftok("shared_memory_key", 65);  // 生成一个唯一的key值

    // 创建共享内存段
    shm_id = shmget(key, SHM_SIZE, IPC_CREAT | 0666);
    if (shm_id < 0) {
        perror("shmget");
        exit(1);
    }

    // 将共享内存映射到当前进程的地址空间
    shared_memory = (char*) shmat(shm_id, NULL, 0);
    if (shared_memory == (char *) -1) {
        perror("shmat");
        exit(1);
    }

    // 写入数据到共享内存
    strcpy(shared_memory, "Hello, shared memory!");

    // 创建一个子进程
    pid_t pid = fork();

    if (pid == 0) {
        // 子进程读取共享内存中的数据并打印
        printf("Child Process: %s\n", shared_memory);
    } else if (pid > 0) {
        // 父进程等待子进程完成
        wait(NULL);
        printf("Parent Process: %s\n", shared_memory);
    } else {
        perror("fork");
        exit(1);
    }

    // 解除共享内存的映射
    shmdt(shared_memory);

    // 删除共享内存段
    shmctl(shm_id, IPC_RMID, NULL);

    return 0;
}

---------查看系统CPU处理器位数信息-------
adb shell
cat /proc/cpuinfo

-----------守护进程-----------------
SIGHUP信号：
忽略信号SIGHUP 挂断，在用户终端连接（正常或非正常）结束时发出，
通常是在终端的控制进程结束时，通知同一session内的各个作业，这时它们与终端不再关联
登录Linux时，系统会分配给登录用户一个终端(Session)。
在这个终端运行的所有程序，包括前台进程组和 后台进程组，一般都属于这个 Session。
当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。
这个信号的默认操作为终止进程，因此前台进 程组和后台有终端输出的进程就会中止。
不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录，wget也 能继续下载。
此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。
······················································································
创建会话并设置进程组ID
#include <sys/types.h>
#include <unistd.h>
函数：pid_t setsid(void);
函数说明：当进程是会话的领头进程时setsid()调用失败并返回(-1)
setsid()调用成功后，返回新的会话的ID，调用setsid函数的进程成为新的会话的领头进程，
并与其父进程的会话组合进程组脱离。由于会话对控制终端的独占性，进程同同时与控制终端脱离。
······················································································
int setpgrp(void); 将进程的PGID设置为PID相同的数值。
······················································································
获取系统配置信息
#include <unistd.h>
函数：long sysconf(int name);
函数说明：用于获取系统配置信息，允许您查询有关运行时环境的参数，例如内存页大小、最大打开文件数、CPU核心数等。
这些参数可以帮助您编写更具有可移植性的代码，因为它们可以根据不同的系统和硬件配置来自动适应。
参数：name 是一个常量，用于指定要查询的系统配置参数。这些常量通常以’_SC_‘开头，定义在头文件’<unistd.h>‘中
返回值：根据查询的配置参数，sysconf 函数返回相应的配置值。如果查询失败，返回值为 -1，同时设置 errno 以表示错误原因。

_SC_ARG_MAX：命令行参数的最大字节数。
_SC_CHILD_MAX：可创建的子进程数的最大值。
_SC_CLK_TCK：每秒的时钟滴答数，用于计算时钟时间单位。
_SC_OPEN_MAX：进程能够同时打开的最大文件数。
_SC_PAGESIZE：内存页的大小。
_SC_PHYS_PAGES：系统物理内存页数。
_SC_NPROCESSORS_CONF：系统中可用的CPU核心数（配置数）。
_SC_NPROCESSORS_ONLN：当前在线的CPU核心数。
_SC_STREAM_MAX：同时打开的最大流（例如，文件流）数。

例子：
#include <stdio.h>
#include <unistd.h>

int main() {
    long pageSize = sysconf(_SC_PAGESIZE);
    printf("Page size: %ld bytes\n", pageSize);

    return 0;
}
······················································································
设置文件创建权限掩码
#include <sys/stat.h>
函数：mode_t umask(mode_t mask);
函数说明：用于设置文件创建权限掩码的函数，它在标准C库（libc）中提供。
文件创建权限掩码决定了新创建的文件的默认权限。通过调整权限掩码，
可以更改文件的默认权限，从而影响新创建的文件的访问权限。
参数：mask：一个权限掩码，用于指定要设置的新的权限掩码。在新创建的文件权限中，与 mask 对应的位将会被清除，而其他位将会保留。
返回值：返回权限掩码。
说明：默认情况下，文件创建权限掩码为’0022‘，它表示新创建的文件将会有权限 0644（即 -rw-r--r--），其中所有者有读写权限，其他用户只有读权限。umask函数影响的是进程范围内的文件创建权限掩码，不会对其他正在运行的进程产生影响。
也可在终端中直接使用命令临时修改一旦重启或重新登录系统就会失效
[root@localhost ~]# umask 002
如果想修改永久生效需要修改配置文件 /etc/profile
例子：
.....省略部分内容.....
if [ $UID -gt 199]&&[ "'id -gn'" = "'id -un'" ]; then
    umask 002
    #如果UID大于199（普通用户），则使用此umask值
else
    umask 022
    #如果UID小于199（超级用户），则使用此umask值
fi
.....省略部分内容.....
上例详解:
$UID -gt 199 :这是一个条件，用于检查当前用户的用户ID（UID）是否大于199。在Unix和Linux系统中，普通用户的UID通常从1000开始，而系统用户和服务用户的UID值较低。因此，条件检查 $UID -gt 199 实际上是在检查当前用户是否为普通用户。
&& :这是逻辑AND操作符，它连接两个条件，只有在两个条件都为真（非零）时，整个表达式才为真。在这里，它用于将上述的UID检查与下一个条件连接起来。
[ "'id -gn'" = "'id -un'" ] :
    id -gn :这是一个命令替换,将返回当前用户的用户名.
    id -un :这也是一个命令替换,将返回当前用户的用户名.
      "'id -gn'" = "'id -un'" :这是一个字符串比较操作，它比较两个字符串是否相等。在这里，它比较用户的组名和用户名是否相同。

例子:
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>

int main() {
    // 设置新的文件创建权限掩码为 0077，即新创建的文件将没有任何权限
    mode_t oldMask = umask(0077);

    // 创建一个新文件
    int fd = open("example.txt", O_CREAT | O_WRONLY, 0666);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    // 关闭文件
    close(fd);

    // 恢复之前的文件创建权限掩码
    umask(oldMask);

    return 0;
}
··························································
将当前的工作目录改变成以参数路径所指的目录
#include <unistd.h>
函数:int chdir(const char * path);
函数说明:用于改变当前工作目录（current working directory）或进程的当前目录。当前工作目录是指在执行文件和目录操作时，相对路径将基于此目录进行解析。通过更改当前工作目录，您可以在不使用绝对路径的情况下执行文件和目录操作。
参数:一个以 null 结尾的字符串，表示要切换到的目标目录的路径。
返回值:如果函数调用成功，返回值为 0。如果函数调用失败，返回值为 -1，并设置 errno 来指示错误的原因。
说明:当前工作目录的更改在整个进程中持续有效，直到进程终止或再次调用 chdir 函数。
例子:
#include <stdio.h>
#include <unistd.h>

int main() {
    const char *newDir = "/path/to/new/directory";

    if (chdir(newDir) == 0) {
        printf("Changed current directory to: %s\n", newDir);
    } else {
        perror("chdir");
    }

    return 0;
}
··························································
粤嵌例子：
int main(void)
{
	pid_t a;
	int max_fd, i;

	/*********************************************
	1. ignore the signal SIGHUP, prevent the
	   process from being killed by the shutdown
	   of the present controlling termination
	忽略信号SIGHUP，防止进程被当前控制终止的关闭杀死
	**********************************************/
	signal(SIGHUP, SIG_IGN);

	/***************************************
	2. generate a child process, to ensure
	   successfully calling setsid()
	生成一个子进程，以确保成功调用setsid()
	****************************************/
	a = fork();
	if(a > 0)
		exit(0);

	/******************************************************
	3. call setsid(), let the first child process running
	   in a new session without a controlling termination
	调用setsid()，让第一个子进程在没有控制终止的新会话中运行
	*******************************************************/
	setsid();

	/*************************************************
	4. generate the second child process, to ensure
	   that the daemon cannot open a terminal file
	   to become its controlling termination
	生成第二个子进程，以确保守护进程不能打开终端文件成为其控制终端
	**************************************************/
	a = fork();
	if(a > 0)
		exit(0);

	/*********************************************************
	5. detach the daemon from its original process group, to
	   prevent any signal sent to it from being delivered
	将守护进程从其原始进程组中分离出来，以防止发送给它的任何信号被传递
	**********************************************************/
	setpgrp();

	/*************************************************
	6. close any file descriptor to release resource
	关闭任何文件描述符以释放资源
	**************************************************/
	max_fd = sysconf(_SC_OPEN_MAX);
	for(i=0; i<max_fd; i++)
		close(i);

	/******************************************
	7. clear the file permission mask to zero
	将文件权限掩码清除为零
	*******************************************/
	umask(0);

	/****************************************
	8. change the process's work directory,
	   to ensure it won't be uninstalled
	更改进程的工作目录，以确保它不会被卸载
	*****************************************/
	chdir("/");

	// Congratulations! Now, this process is a DAEMON!
	// 创建守护进程成功
	pause();
	return 0;
}
-------------线程------------------------------
创建线程
#include <pthread.h>
函数：int pthread_create(pthread_t *thread,
			const pthread_attr_t *attr,
			void *(*start_routine)(void *),
			void *arg);
函数说明：创建一个线程
参数：thread：新线程的tid，attr：线程属性，若创建标准线程则该参数可设置为NULL，
start_routine：线程函数，arg：线程函数的参数
返回值：如果成功，pthread_create()返回0;当出现错误时，它返回一个错误编号，并且*thread的内容为未定义的。
说明：使用-phread编译和链接
例子：
#include <pthread.h>

void *doSomething(void *arg)
{
    // ...
}

int main()
{
    // 创建一条线程，并让其执行函数 doSomething()
    pthread_t tid;
    pthread_create(&tid, NULL, doSomething, NULL);

    // ...
}
说明：上面例子，线程函数的输出和主线程的输出是并发的，可能会出现，主线程先结束，导致线程函数结束。
不能判断线程函数和主线程执行的先后速度，是不确定的。
····················································
线程退出
#include <pthread.h>
函数：void pthread_exit(void *retval);
函数说明：用于显式地终止当前线程的执行。调用该函数后，当前线程会立即退出，而不会等待其他线程完成。
参数：retval：指定线程的退出状态，通常是一个指针。这个指针可以被其他线程通过 pthread_join 函数来获取。
说明：该函数没有返回值

例子：
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void *thread_function(void *arg) {
    int *value = (int *)arg;
    printf("Thread value: %d\n", *value);
    *value *= 2;  // Modify the value
    printf("*value = %d\n", *value);
    pthread_exit(value);
}

int main() {
    pthread_t thread;
    int value = 5;

    pthread_create(&thread, NULL, thread_function, &value);
    void *exit_status;

    pthread_join(thread, &exit_status);
    int *result = (int *)exit_status;

    printf("Main thread: Thread exited with value: %d\n", *result);

    return 0;
}
输出：
Thread value: 5
*value  = 10 
Main thread: Thread exited with value: 10
····················································
线程的接合
#include <pthread.h>
函数：int pthread_join(pthread_t thread,void **retval);
函数说明：作用是阻塞调用线程，直到指定的线程 `thread` 终止。一旦被等待的线程 `thread` 终止，`pthread_join` 函数会返回，同时将线程的退出状态（通过 `retval` 参数）传递给调用线程。
参数：thread：是一个pthread_t类型的线程标识符，用于指定等待的线程，retval：是指向指针的指针，用于接收被等待线程的返回值，如果不关心被等待的返回值，可以将该参数设置为'NULL'

例子：
#include <stdio.h>
#include <pthread.h>

void *thread_function(void *arg) {
    int *value = (int *)arg;
    printf("Thread function: %d\n", *value);
    *value = 42;
    return NULL;
}

int main() {
    pthread_t thread;
    int value = 10;

    // 创建线程
    pthread_create(&thread, NULL, thread_function, &value);

    // 等待线程终止并获取返回值
    pthread_join(thread, NULL);

    printf("Main thread: %d\n", value);

    return 0;
}
输出：
Thread function: 10
Main thread: 42
····················································
获取线程ID
#include <pthread.h>
函数：pthread_t pthread_self(void);
函数说明：返回调用线程的线程标识符，这个标识符可以用来在程序中唯一地标识一个线程。每个线程都有一个唯一的线程标识符。
说明：pthread_self 函数返回的 pthread_t 标识符只在同一进程内有效。这个标识符是用于在进程内唯一标识线程的值，不适用于跨进程通信或线程标识符的全局唯一性。

例子：
#include <stdio.h>
#include <pthread.h>

void *thread_function(void *arg) {
    pthread_t tid = pthread_self();
    printf("Thread ID: %lu\n", tid);
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, thread_function, NULL);
    pthread_create(&thread2, NULL, thread_function, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    return 0;
}
····················································
函数单例
#include <pthread.h>
函数：int pthread_once(pthread_once_t *once_control,void (*init_routine)(void));
函数说明：pthread_once 函数的作用是在多线程环境下确保 init_routine 函数只被执行一次，无论有多少个线程尝试调用它。
参数：once_control：这是一个指向pthread_once_t类型的控制变量的指针，这个控制变量用来跟踪初始化过程是否完成。通常将控制变量定义为全局变量，确保在所有线程可见，init_routine：这是一个指向函数的指针，表示要执行的初始化代码，这个函数应该没有参数和返回值，它只会被执行一次。
返回值：如果初始化代码已经执行过，pthread_once函数将返回0，如果初始化代码尚未执行，它会执行init_routine并返回非零值
说明：记得设置全局变量pthread_once_t：pthread_once_t once_control = PTHREAD_ONCE_INIT;

例子：
#include <stdio.h>
#include <pthread.h>

pthread_once_t once_control = PTHREAD_ONCE_INIT;

void initialize_resource() {
    printf("Initializing resource...\n");
    // 这里可以放置需要执行的初始化代码
}

void *thread_function(void *arg) {
    pthread_once(&once_control, initialize_resource);
    printf("Thread is using the initialized resource.\n");
    return NULL;
}

int main() {
    pthread_t threads[5];

    for (int i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, thread_function, NULL);
    }

    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}
····················································
线程属性
属性归总表格：
获取属性API与功能						设置属性API和功能
pthread_attr_getdetachstate( )     //分离属性           pthread_attr_setdetachstate( )         
pthread_attr_getguardsize( )       //栈警戒区大小               pthread_attr_setguardsize( ) 
pthread_attr_getinheritsched( )    //继承策略                      pthread_attr_setinheritsched( )
pthread_attr_getschedpolicy( )     //调度策略                      pthread_attr_setschedpolicy( )
pthread_attr_getschedparam( )      //调度参数                      pthread_attr_setschedparam( )	
pthread_attr_getscope( )           //竞争范围                      pthread_attr_setscope( )
pthread_attr_getaffinity_np( )     //CPU亲和度          pthread_attr_setaffinity_np( )	
pthread_attr_getstack( )           //栈指针和栈大小            pthread_attr_setstack( )
pthread_attr_getstacksize( )       //栈大小                          pthread_attr_setstacksize( )

#include <pthread.h>
函数：int pthread_attr_getdetachstate(const pthread_attr_t *attr,int *detachstate);
函数说明：函数是 POSIX 线程库（Pthreads）中用于获取线程分离状态属性的函数，
分离状态属性决定了线程的结束时如何进行资源的清理和回收。
参数：attr：指向要查询分离状态属性的线程属性对象的指针，detachstate：用于存储获取到的分离状态属性的变量的指针
返回值：成功返回 0，失败返回一个非零错误码。

例子：
#include <pthread.h>
#include <stdio.h>

int main() {
    pthread_attr_t attr;
    pthread_attr_init(&attr);  // 初始化线程属性对象

    int detachstate;
    pthread_attr_getdetachstate(&attr, &detachstate);

    if (detachstate == PTHREAD_CREATE_JOINABLE) {
        printf("Thread is joinable.\n");
    } else if (detachstate == PTHREAD_CREATE_DETACHED) {
        printf("Thread is detached.\n");
    } else {
        printf("Unknown detach state.\n");
    }

    // 在这里执行其他操作

    pthread_attr_destroy(&attr);  // 销毁线程属性对象

    return 0;
}
输出：Thread is joinable.

#include <pthread.h>
函数：int pthread_attr_init(pthread_attr_t *attr);
      int pthread_attr_destroy(pthread_attr_t *attr);
函数说明：init函数是初始化线程属性的函数，
destroy函数是用于销毁线程属性对象，当线程属性对象不再需要，应该使用这个函数来释放相关的资源，避免内存泄漏。
他们都是POSIX线程库(Pthreads)函数
参数：attr：指向要初始化或者要销毁的线程属性对象的指针

#include <pthread.h>
函数：int pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate);
函数说明：函数是 POSIX 线程库（Pthreads）中用于设置线程分离状态属性的函数。
分离状态属性决定了线程的结束时如何进行资源的清理和回收。
参数：attr：指向要设置分离状态属性的线程属性对象的指针，
detachstate：分离状态属性取值为以下两种：
PTHREAD_CREATE_JOINABLE：表示线程是可连接（joinable）的，即线程结束后需要调用 pthread_join 函数来等待线程结束并回收资源。
PTHREAD_CREATE_DETACHED：表示线程是分离（detached）的，即线程结束后会自动回收资源，无需调用 pthread_join。
返回值：成功返回 0，失败返回一个非零错误码。

例子：
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

#include <pthread.h>

void *routine(void *arg __attribute__((unused)))
{
    sleep(1);
}

int main()
{
    // 初始化属性变量，并将分离属性添加进去
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    // 以分离属性启动线程
    pthread_t tid;
    pthread_create(&tid, &attr, routine, NULL);

    // 分离的线程无法接合
    if((errno=pthread_join(tid, NULL)) != 0)
        perror("接合线程失败");

    pthread_exit(NULL);
}

强制分离
在线程启动后，使用 pthread_detach() 强制分离的做法如下：
例子：
#include <pthread.h>

void *routine(void *arg)
{
    // 强制将自身设置为分离状态
    pthread_detach(pthread_self());

    // ...
}

int main()
{
    // 启动标准线程
    pthread_t tid;
    pthread_create(&tid, NULL, routine, NULL);

    // ...
}

说明：由于线程是无序的，如下例子，有时会成功，有时候会失败，！！！
#include <pthread.h>

void *routine(void *arg)
{
    // 将自身强制分离，然后退出
    pthread_detach(pthread_self());
    pthread_exit("abcd");
}

int main()
{
    pthread_t tid;
    pthread_create(&tid, NULL, routine, NULL);

    char *s;
    if((errno=pthread_join(tid, (void *)&s)) != 0)
        perror("接合线程失败");
    else
        printf("接合线程成功:%s\n", s);

    pthread_exit(NULL);
}
-----------------同步互斥机制-----------------------



------------------------------------------
ARM和ROM的区别
    ram是指通过指令可以随机访问每个存储单元的存储器。一般来说，访问时间基本固定，与存储单元地址无关。ram速度相对较快，但其保存的信息需要电力支持。一旦供电丢失，数据就会消失，因此它也被称为易失性存储器。另一个有趣的名字是挥发性存储器。当然，这里的挥发性是数据而不是物理芯片。在51单片机中，ram主要用于保存数据、中间结果和操作程序，因此ram也被称为数据存储器。
    rom英文全称Read Only Memory，只读存储器，是一种内存类型。这种内存通常用于存储重要或机密的数据。理想情况下，这种类型的内存只能读取，不允许擦写。在51单片机中，rom通常用于存储常数、数据表、程序代码等，因此也称为程序存储器。
补充：电脑硬盘和ROM有什么关系：
ROM和硬盘都可以存储数据而且断电不会丢失，硬盘分为两种，一种师机械硬盘（即磁盘HDD），一种是固态硬盘（SDD），磁盘与ROM没有什么关系，固态硬盘用到的颗粒也是基于NAND FLASH技术，固态硬盘的存储颗粒是ROM技术发展的产物，但不能说ROM就算硬盘


=====================================================================================================================
FAE
--------------
AP: Access Point
也就是无线接入点，是一个无线网络的创建者，是网络的中心节点。一般家庭或者办公室使用的无线路由器就是一个AP
STA: Station
每一个连接到无线网络中的终端（如笔记本电脑，PDA以及它可以联网的用户设备）都可以称为一个站点
SSID: Service Set Identifier
每个无线AP都有一个标示用于用户识别，SSID


=====================================================================================================================
